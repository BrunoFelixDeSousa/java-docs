# SmallRye JWT - Autentica√ß√£o e Autoriza√ß√£o com JSON Web Tokens

## √çndice
1. [Introdu√ß√£o](#1-introdu√ß√£o)
2. [Conceitos Fundamentais](#2-conceitos-fundamentais)
3. [Setup e Configura√ß√£o](#3-setup-e-configura√ß√£o)
4. [Gera√ß√£o de Tokens](#4-gera√ß√£o-de-tokens)
5. [Valida√ß√£o e Verifica√ß√£o](#5-valida√ß√£o-e-verifica√ß√£o)
6. [Prote√ß√£o de Endpoints](#6-prote√ß√£o-de-endpoints)
7. [Claims Customizadas](#7-claims-customizadas)
8. [Refresh Tokens](#8-refresh-tokens)
9. [Integra√ß√£o com Frontend](#9-integra√ß√£o-com-frontend)
10. [Configura√ß√µes Avan√ßadas](#10-configura√ß√µes-avan√ßadas)
11. [Testes](#11-testes)
12. [Seguran√ßa e Boas Pr√°ticas](#12-seguran√ßa-e-boas-pr√°ticas)
13. [Troubleshooting](#13-troubleshooting)
14. [Recursos e Refer√™ncias](#14-recursos-e-refer√™ncias)

---

## 1. Introdu√ß√£o

### 1.1 O que √© JWT?

**JWT (JSON Web Token)** √© um padr√£o aberto (RFC 7519) para transmitir informa√ß√µes de forma segura entre partes como um objeto JSON. √â amplamente utilizado para autentica√ß√£o e troca de informa√ß√µes em aplica√ß√µes web e APIs.

#### Analogia do Mundo Real

Imagine que voc√™ vai a um parque de divers√µes:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. ENTRADA (Login)                                      ‚îÇ
‚îÇ    Voc√™ compra um ingresso (token)                      ‚îÇ
‚îÇ    Ingresso cont√©m: Nome, Tipo (VIP/Normal), Validade  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. BRINQUEDOS (Recursos Protegidos)                    ‚îÇ
‚îÇ    Mostra o ingresso para funcion√°rio                   ‚îÇ
‚îÇ    Funcion√°rio verifica se √© v√°lido e se tem permiss√£o  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. ACESSO (Autoriza√ß√£o)                                 ‚îÇ
‚îÇ    VIP ‚Üí Acesso total                                   ‚îÇ
‚îÇ    Normal ‚Üí Acesso limitado                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

O **JWT** funciona exatamente assim: √© um "ingresso digital" que prova quem voc√™ √© e o que pode fazer.

### 1.2 Estrutura do JWT

Um JWT √© composto por tr√™s partes separadas por pontos (`.`):

```
[Header].[Payload].[Signature]
```

#### Exemplo Visual

```
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ

‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          HEADER                 ‚îÇ                    PAYLOAD                             ‚îÇ           SIGNATURE              ‚îÇ
‚îÇ     (Algoritmo e Tipo)          ‚îÇ              (Dados do Usu√°rio)                        ‚îÇ        (Valida√ß√£o)               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### 1. Header (Cabe√ßalho)

Cont√©m metadados sobre o token:

```json
{
  "alg": "RS256",    // Algoritmo de assinatura (RSA SHA-256)
  "typ": "JWT"       // Tipo do token
}
```

#### 2. Payload (Carga √ötil)

Cont√©m as **claims** (declara√ß√µes) sobre a entidade:

```json
{
  "sub": "1234567890",           // Subject (ID do usu√°rio)
  "name": "Jo√£o Silva",          // Nome
  "email": "joao@example.com",   // Email
  "groups": ["admin", "user"],   // Roles/Grupos
  "iat": 1516239022,             // Issued At (quando foi criado)
  "exp": 1516242622,             // Expiration (quando expira)
  "iss": "https://meuapp.com"    // Issuer (quem emitiu)
}
```

#### 3. Signature (Assinatura)

Garante que o token n√£o foi alterado:

```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
```

### 1.3 O que √© SmallRye JWT?

**SmallRye JWT** √© a implementa√ß√£o do Quarkus da especifica√ß√£o **MicroProfile JWT RBAC**, que define um padr√£o interoper√°vel para usar JWT em microservi√ßos Java.

#### Caracter√≠sticas Principais

| Caracter√≠stica | Descri√ß√£o |
|----------------|-----------|
| **Baseado em Padr√µes** | Segue MicroProfile JWT 2.1 |
| **Integra√ß√£o Nativa** | Totalmente integrado ao Quarkus Security |
| **Gera√ß√£o Simples** | API fluente para criar tokens |
| **Valida√ß√£o Autom√°tica** | Verifica√ß√£o de assinatura, expira√ß√£o, issuer |
| **CDI Friendly** | Inje√ß√£o de depend√™ncias para claims |
| **Configur√°vel** | Suporte a m√∫ltiplos issuers, algoritmos, etc. |

### 1.4 Fluxo de Autentica√ß√£o JWT

```mermaid
sequenceDiagram
    participant C as Cliente
    participant A as Auth Service
    participant R as Resource Service
    participant DB as Database
    
    C->>A: 1. POST /auth/login<br/>{username, password}
    A->>DB: 2. Verificar credenciais
    DB-->>A: 3. Usu√°rio v√°lido
    A->>A: 4. Gerar JWT com claims
    A-->>C: 5. {accessToken, refreshToken}
    
    Note over C: Armazena tokens
    
    C->>R: 6. GET /api/protected<br/>Authorization: Bearer [token]
    R->>R: 7. Validar assinatura
    R->>R: 8. Verificar expira√ß√£o
    R->>R: 9. Verificar roles
    R-->>C: 10. Dados protegidos
    
    Note over C: Token expira
    
    C->>A: 11. POST /auth/refresh<br/>{refreshToken}
    A->>A: 12. Validar refresh token
    A-->>C: 13. {novo accessToken}
```

### 1.5 Vantagens do JWT

#### ‚úÖ Benef√≠cios

1. **Stateless** üîì
   - Servidor n√£o precisa armazenar sess√µes
   - Escala horizontalmente sem problemas
   - Ideal para microservi√ßos

2. **Autocontido** üì¶
   - Cont√©m todas as informa√ß√µes necess√°rias
   - Reduz chamadas ao banco de dados
   - Claims podem ser lidas sem valida√ß√£o

3. **Port√°vel** üåê
   - Funciona em qualquer plataforma
   - Pode ser usado em HTTP headers, cookies, URL
   - Padr√£o aberto (RFC 7519)

4. **Seguro** üîí
   - Assinado criptograficamente
   - Opcionalmente encriptado (JWE)
   - Detecta adultera√ß√£o

#### ‚ö†Ô∏è Desvantagens e Cuidados

1. **N√£o pode ser revogado facilmente**
   - Token √© v√°lido at√© expirar
   - Necess√°rio implementar blacklist para revoga√ß√£o
   - Use TTL curto para access tokens

2. **Tamanho**
   - Maior que session IDs tradicionais
   - Cada requisi√ß√£o carrega o token completo
   - Evite claims desnecess√°rias

3. **Seguran√ßa do Secret/Key**
   - Se a chave vazar, todos os tokens podem ser forjados
   - Use chaves fortes (m√≠nimo 256 bits)
   - Rotacione chaves periodicamente

### 1.6 JWT vs. Sess√µes Tradicionais

| Aspecto | JWT | Sess√µes Tradicionais |
|---------|-----|----------------------|
| **Armazenamento** | Cliente (token) | Servidor (mem√≥ria/Redis) |
| **Stateful/Stateless** | Stateless ‚úÖ | Stateful ‚ùå |
| **Escalabilidade** | Excelente ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Requer sticky sessions ‚≠ê‚≠ê‚≠ê |
| **Tamanho** | Maior (~200-500 bytes) | Menor (session ID ~32 bytes) |
| **Revoga√ß√£o** | Dif√≠cil ‚ùå | F√°cil ‚úÖ |
| **Performance** | Sem consulta DB ‚úÖ | Consulta a cada request ‚ùå |
| **Ideal para** | APIs, Microservi√ßos, Mobile | Aplica√ß√µes monol√≠ticas |

### 1.7 Casos de Uso

#### ‚úÖ Use JWT quando:

- Construindo APIs RESTful
- Arquitetura de microservi√ßos
- Single Sign-On (SSO)
- Aplica√ß√µes mobile
- Servi√ßos distribu√≠dos
- Necessita escalar horizontalmente

#### ‚ùå Evite JWT quando:

- Sistema com revoga√ß√£o frequente de acesso
- Dados sens√≠veis no token (preferir JWE)
- Aplica√ß√£o monol√≠tica simples
- Sess√µes de longa dura√ß√£o (horas/dias)

### 1.8 Algoritmos de Assinatura

| Algoritmo | Tipo | Descri√ß√£o | Uso Recomendado |
|-----------|------|-----------|-----------------|
| **HS256** | Sim√©trico | HMAC + SHA-256 | Desenvolvimento, servi√ßos internos |
| **RS256** | Assim√©trico | RSA + SHA-256 | **Produ√ß√£o (recomendado)** |
| **ES256** | Assim√©trico | ECDSA + SHA-256 | Alta performance, tokens pequenos |
| **PS256** | Assim√©trico | RSA-PSS + SHA-256 | M√°xima seguran√ßa |

**Recomenda√ß√£o**: Use **RS256** em produ√ß√£o com chaves de no m√≠nimo 2048 bits.

---

## 2. Conceitos Fundamentais

### 2.1 Claims (Declara√ß√µes)

**Claims** s√£o afirma√ß√µes sobre uma entidade (tipicamente o usu√°rio) e metadados adicionais.

#### Tipos de Claims

| Tipo | Descri√ß√£o | Exemplos |
|------|-----------|----------|
| **Registered** | Claims padr√£o (RFC 7519) | `iss`, `sub`, `exp`, `iat`, `nbf` |
| **Public** | Claims p√∫blicas registradas | `name`, `email`, `preferred_username` |
| **Private** | Claims customizadas da aplica√ß√£o | `userId`, `department`, `permissions` |

#### Claims Registradas (Padr√£o)

```java
/**
 * Claims padr√£o do JWT (RFC 7519)
 */
public class StandardClaims {
    
    // iss (Issuer) - Quem emitiu o token
    String issuer = "https://meuapp.com";
    
    // sub (Subject) - Sobre quem √© o token (geralmente user ID)
    String subject = "user123";
    
    // aud (Audience) - Para quem o token √© destinado
    String audience = "api.meuapp.com";
    
    // exp (Expiration Time) - Quando o token expira (Unix timestamp)
    long expiration = 1735680000; // 31/12/2024 23:59:59
    
    // nbf (Not Before) - Quando o token se torna v√°lido
    long notBefore = 1704067200; // 01/01/2024 00:00:00
    
    // iat (Issued At) - Quando o token foi emitido
    long issuedAt = 1704067200;
    
    // jti (JWT ID) - Identificador √∫nico do token
    String jwtId = "a1b2c3d4-e5f6-4a5b-8c9d-0e1f2a3b4c5d";
}
```

#### MicroProfile JWT Claims

Claims espec√≠ficas da especifica√ß√£o MicroProfile:

```java
/**
 * Claims do MicroProfile JWT
 */
public class MicroProfileClaims {
    
    // upn (User Principal Name) - Nome principal do usu√°rio
    String upn = "joao.silva@empresa.com";
    
    // groups - Grupos/Roles do usu√°rio
    Set<String> groups = Set.of("admin", "user", "manager");
    
    // preferred_username - Nome de usu√°rio preferido
    String preferredUsername = "joao.silva";
}
```

### 2.2 Roles e Grupos

**Roles** (pap√©is) definem o que um usu√°rio pode fazer na aplica√ß√£o.

```java
/**
 * Hierarquia de Roles
 */
public enum Role {
    // Usu√°rio comum - acesso b√°sico
    USER("user"),
    
    // Gerente - acesso intermedi√°rio
    MANAGER("manager"),
    
    // Administrador - acesso total
    ADMIN("admin"),
    
    // Super Admin - acesso irrestrito
    SUPER_ADMIN("super_admin");
    
    private final String roleName;
    
    Role(String roleName) {
        this.roleName = roleName;
    }
}
```

#### Exemplo de Permiss√µes por Role

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ADMIN                                                       ‚îÇ
‚îÇ ‚îú‚îÄ Gerenciar usu√°rios                                       ‚îÇ
‚îÇ ‚îú‚îÄ Configurar sistema                                       ‚îÇ
‚îÇ ‚îú‚îÄ Ver relat√≥rios                                           ‚îÇ
‚îÇ ‚îî‚îÄ Todas as permiss√µes de MANAGER                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ MANAGER                                                     ‚îÇ
‚îÇ ‚îú‚îÄ Aprovar pedidos                                          ‚îÇ
‚îÇ ‚îú‚îÄ Ver equipe                                               ‚îÇ
‚îÇ ‚îî‚îÄ Todas as permiss√µes de USER                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ USER                                                        ‚îÇ
‚îÇ ‚îú‚îÄ Ver perfil                                               ‚îÇ
‚îÇ ‚îú‚îÄ Editar perfil                                            ‚îÇ
‚îÇ ‚îî‚îÄ Criar pedidos                                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2.3 Access Token vs Refresh Token

#### Access Token

- **Curta dura√ß√£o** (5-15 minutos)
- Usado em cada requisi√ß√£o √† API
- Cont√©m todas as claims necess√°rias
- Se comprometido, impacto limitado (expira r√°pido)

#### Refresh Token

- **Longa dura√ß√£o** (dias, semanas ou meses)
- Usado apenas para obter novos access tokens
- Armazenado de forma mais segura
- Pode ser revogado no servidor

```mermaid
graph LR
    A[Login] --> B[Gera Access Token<br/>15 min]
    A --> C[Gera Refresh Token<br/>7 dias]
    
    B --> D[Requisi√ß√µes √† API]
    
    D --> E{Token<br/>expirou?}
    E -->|N√£o| D
    E -->|Sim| F[Usa Refresh Token]
    
    F --> G[Novo Access Token]
    G --> D
    
    C --> H{Refresh<br/>expirou?}
    H -->|Sim| I[Login novamente]
    I --> A
    
    style B fill:#c8e6c9
    style C fill:#fff9c4
    style E fill:#ffccbc
```

### 2.4 Chaves Assim√©tricas (Public/Private Key)

SmallRye JWT usa criptografia assim√©trica (RSA) para assinar e validar tokens.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ CHAVE PRIVADA (Private Key)                                ‚îÇ
‚îÇ ‚îú‚îÄ Mantida em SEGREDO no servidor                          ‚îÇ
‚îÇ ‚îú‚îÄ Usada para ASSINAR tokens                               ‚îÇ
‚îÇ ‚îî‚îÄ Nunca compartilhada                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
                    [Gera Token]
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ JWT ASSINADO                                                ‚îÇ
‚îÇ eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWI...            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
                   [Envia ao Cliente]
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ CHAVE P√öBLICA (Public Key)                                  ‚îÇ
‚îÇ ‚îú‚îÄ Pode ser compartilhada                                   ‚îÇ
‚îÇ ‚îú‚îÄ Usada para VALIDAR assinatura                           ‚îÇ
‚îÇ ‚îî‚îÄ Distribu√≠da para servi√ßos que validam tokens            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Vantagens**:
- ‚úÖ Chave privada fica apenas no auth service
- ‚úÖ Outros servi√ßos s√≥ precisam da chave p√∫blica
- ‚úÖ N√£o √© poss√≠vel forjar tokens sem a chave privada
- ‚úÖ Ideal para arquitetura de microservi√ßos

### 2.5 Token Expiration e Lifecycle

```java
/**
 * Ciclo de vida de um JWT
 */
public class TokenLifecycle {
    
    // 1. CRIA√á√ÉO
    Instant now = Instant.now();
    Instant expiration = now.plus(15, ChronoUnit.MINUTES);
    
    String token = Jwt.issuer("https://meuapp.com")
        .upn("joao.silva")
        .groups(Set.of("user"))
        .issuedAt(now.getEpochSecond())
        .expiresAt(expiration.getEpochSecond())
        .sign();
    
    // 2. USO (0-15 minutos)
    // Token √© v√°lido e pode ser usado
    
    // 3. PR√ìXIMO DA EXPIRA√á√ÉO (13-15 minutos)
    // Frontend pode renovar proativamente
    
    // 4. EXPIRADO (> 15 minutos)
    // Token inv√°lido - 401 Unauthorized
    
    // 5. RENOVA√á√ÉO
    // Usar refresh token para obter novo access token
}
```

#### Estrat√©gias de Expira√ß√£o

| Estrat√©gia | Access Token | Refresh Token | Uso |
|------------|--------------|---------------|-----|
| **Ultra Seguro** | 5 min | 1 hora | Banking, Sa√∫de |
| **Balanceado** | 15 min | 7 dias | SaaS, E-commerce |
| **Conveniente** | 1 hora | 30 dias | Redes sociais, Blogs |
| **Longo Prazo** | 1 dia | 90 dias | Dispositivos confi√°veis |

### 2.6 Contexto de Seguran√ßa

```mermaid
graph TD
    A[HTTP Request com JWT] --> B[Quarkus Security]
    B --> C{Validar<br/>Token}
    
    C -->|Inv√°lido| D[401 Unauthorized]
    C -->|V√°lido| E[Extrair Claims]
    
    E --> F[SecurityIdentity]
    F --> G[Principal]
    F --> H[Roles]
    F --> I[Attributes]
    
    G --> J[Verificar @RolesAllowed]
    H --> J
    
    J -->|Sem permiss√£o| K[403 Forbidden]
    J -->|Permitido| L[Executar Endpoint]
    
    style C fill:#fff3e0
    style D fill:#ffcdd2
    style K fill:#ffcdd2
    style L fill:#c8e6c9
```

---

## 3. Setup e Configura√ß√£o

### 3.1 Cria√ß√£o do Projeto

#### M√©todo 1: Quarkus CLI

```powershell
# Criar projeto com SmallRye JWT
quarkus create app com.exemplo:auth-demo `
    --extension=smallrye-jwt,smallrye-jwt-build,resteasy-reactive-jackson

cd auth-demo
```

#### M√©todo 2: Maven

```powershell
mvn io.quarkus:quarkus-maven-plugin:3.15.1:create `
    -DprojectGroupId=com.exemplo `
    -DprojectArtifactId=auth-demo `
    -Dextensions="smallrye-jwt,smallrye-jwt-build,resteasy-reactive-jackson"

cd auth-demo
```

#### M√©todo 3: code.quarkus.io

1. Acesse https://code.quarkus.io
2. Selecione extens√µes:
   - ‚úÖ SmallRye JWT
   - ‚úÖ SmallRye JWT Build
   - ‚úÖ RESTEasy Reactive Jackson
3. Generate

### 3.2 Depend√™ncias Maven

#### pom.xml Completo

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.exemplo</groupId>
    <artifactId>auth-demo</artifactId>
    <version>1.0.0-SNAPSHOT</version>

    <properties>
        <quarkus.version>3.15.1</quarkus.version>
        <java.version>21</java.version>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>io.quarkus.platform</groupId>
                <artifactId>quarkus-bom</artifactId>
                <version>${quarkus.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <!-- SmallRye JWT -->
        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <!-- Valida√ß√£o e autentica√ß√£o com JWT -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-smallrye-jwt</artifactId>
        </dependency>
        
        <!-- Gera√ß√£o de tokens JWT -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-smallrye-jwt-build</artifactId>
        </dependency>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <!-- REST -->
        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-resteasy-reactive</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-resteasy-reactive-jackson</artifactId>
        </dependency>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <!-- Banco de Dados (Opcional)-->
        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-hibernate-orm-panache</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-jdbc-postgresql</artifactId>
        </dependency>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <!-- Valida√ß√£o -->
        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-hibernate-validator</artifactId>
        </dependency>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <!-- Seguran√ßa Adicional -->
        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <!-- BCrypt para hash de senhas -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-elytron-security-common</artifactId>
        </dependency>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <!-- Utilities -->
        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-arc</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-config-yaml</artifactId>
        </dependency>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <!-- Observabilidade -->
        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-smallrye-health</artifactId>
        </dependency>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <!-- Testes -->
        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-junit5</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.rest-assured</groupId>
            <artifactId>rest-assured</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-test-security-jwt</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>io.quarkus</groupId>
                <artifactId>quarkus-maven-plugin</artifactId>
                <version>${quarkus.version}</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>build</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
```

### 3.3 Gera√ß√£o de Chaves RSA

#### PowerShell (Windows)

```powershell
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# 1. Gerar chave privada RSA (2048 bits)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
openssl genrsa -out privatekey.pem 2048

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# 2. Extrair chave p√∫blica da privada
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
openssl rsa -in privatekey.pem -pubout -out publickey.pem

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# 3. Criar diret√≥rio de resources
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
New-Item -ItemType Directory -Force -Path "src\main\resources\META-INF\resources"

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# 4. Mover chaves para o diret√≥rio correto
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Move-Item privatekey.pem src\main\resources\META-INF\resources\
Move-Item publickey.pem src\main\resources\META-INF\resources\

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# 5. Verificar as chaves
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Chave privada
openssl rsa -in src\main\resources\META-INF\resources\privatekey.pem -text -noout

# Chave p√∫blica
openssl rsa -pubin -in src\main\resources\META-INF\resources\publickey.pem -text -noout
```

#### Alternativa: Gerar Chaves Programaticamente

```java
import java.security.*;
import java.util.Base64;

/**
 * Gerador de chaves RSA
 */
public class KeyGenerator {
    
    public static void main(String[] args) throws Exception {
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
        keyGen.initialize(2048);
        
        KeyPair keyPair = keyGen.generateKeyPair();
        
        // Chave privada
        PrivateKey privateKey = keyPair.getPrivate();
        String privateKeyPEM = "-----BEGIN PRIVATE KEY-----\n" +
            Base64.getMimeEncoder(64, "\n".getBytes()).encodeToString(privateKey.getEncoded()) +
            "\n-----END PRIVATE KEY-----";
        
        // Chave p√∫blica
        PublicKey publicKey = keyPair.getPublic();
        String publicKeyPEM = "-----BEGIN PUBLIC KEY-----\n" +
            Base64.getMimeEncoder(64, "\n".getBytes()).encodeToString(publicKey.getEncoded()) +
            "\n-----END PUBLIC KEY-----";
        
        System.out.println("=== PRIVATE KEY ===");
        System.out.println(privateKeyPEM);
        System.out.println("\n=== PUBLIC KEY ===");
        System.out.println(publicKeyPEM);
    }
}
```

### 3.4 Configura√ß√£o - application.properties

```properties
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Aplica√ß√£o
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
quarkus.application.name=auth-demo
quarkus.application.version=1.0.0

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# SmallRye JWT - Valida√ß√£o
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Chave p√∫blica para validar assinatura dos tokens
mp.jwt.verify.publickey.location=META-INF/resources/publickey.pem

# Issuer esperado (deve ser o mesmo do token)
mp.jwt.verify.issuer=https://meuapp.com

# Algoritmo de assinatura
mp.jwt.verify.algorithm=RS256

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# SmallRye JWT - Gera√ß√£o
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Chave privada para assinar tokens
smallrye.jwt.sign.key.location=META-INF/resources/privatekey.pem

# Issuer para tokens gerados
smallrye.jwt.new-token.issuer=https://meuapp.com

# Algoritmo para assinar
smallrye.jwt.new-token.signature-algorithm=RS256

# Dura√ß√£o padr√£o (em segundos) - 15 minutos
smallrye.jwt.new-token.lifespan=900

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Seguran√ßa HTTP
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Endpoints p√∫blicos (n√£o requerem autentica√ß√£o)
quarkus.http.auth.permission.public.paths=/auth/login,/auth/register,/q/*
quarkus.http.auth.permission.public.policy=permit

# Endpoints protegidos (requerem autentica√ß√£o)
quarkus.http.auth.permission.authenticated.paths=/api/*
quarkus.http.auth.permission.authenticated.policy=authenticated

# Apenas admins podem acessar /api/admin/*
quarkus.http.auth.permission.admin.paths=/api/admin/*
quarkus.http.auth.permission.admin.policy=role-admin

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CORS (para desenvolvimento com frontend)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
quarkus.http.cors=true
quarkus.http.cors.origins=http://localhost:3000,http://localhost:4200
quarkus.http.cors.headers=accept,authorization,content-type,x-requested-with
quarkus.http.cors.methods=GET,POST,PUT,DELETE,OPTIONS,PATCH
quarkus.http.cors.exposed-headers=Authorization,X-New-Token

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Datasource (PostgreSQL)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
quarkus.datasource.db-kind=postgresql
quarkus.datasource.username=postgres
quarkus.datasource.password=postgres
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/auth_db

# Hibernate
quarkus.hibernate-orm.database.generation=update
quarkus.hibernate-orm.log.sql=false

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Logging
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
quarkus.log.level=INFO
quarkus.log.category."io.smallrye.jwt".level=DEBUG
quarkus.log.category."com.exemplo".level=DEBUG

quarkus.log.console.format=%d{HH:mm:ss} %-5p [%c{2.}] (%t) %s%e%n

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Dev Mode
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
%dev.quarkus.log.level=DEBUG
%dev.quarkus.hibernate-orm.log.sql=true
%dev.mp.jwt.verify.publickey.location=META-INF/resources/publickey.pem
%dev.smallrye.jwt.sign.key.location=META-INF/resources/privatekey.pem

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Test Profile
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
%test.quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/auth_db_test
%test.quarkus.hibernate-orm.database.generation=drop-and-create

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Production Profile
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
%prod.quarkus.log.level=WARN
%prod.quarkus.http.cors=false
%prod.smallrye.jwt.new-token.lifespan=600
```

---

## 4. Gera√ß√£o de Tokens

### 4.1 Anatomia da Gera√ß√£o de Token

```mermaid
graph TD
    A[Credenciais Validadas] --> B[Criar Builder JWT]
    B --> C[Adicionar Claims Padr√£o]
    C --> C1[issuer - Emissor]
    C --> C2[subject/upn - Usu√°rio]
    C --> C3[exp - Expira√ß√£o]
    C --> C4[iat - Emiss√£o]
    
    C --> D[Adicionar Claims Customizadas]
    D --> D1[userId, email, nome]
    D --> D2[departamento, nivel]
    D --> D3[permissions]
    
    D --> E[Adicionar Roles/Groups]
    E --> E1[admin, user, manager]
    
    E --> F[Assinar com Chave Privada]
    F --> G[Token JWT Completo]
    
    style A fill:#e3f2fd
    style G fill:#c8e6c9
    style F fill:#fff9c4
```

### 4.2 Servi√ßo de Gera√ß√£o Completo

```java
package com.exemplo.auth.service;

import io.smallrye.jwt.build.Jwt;
import io.smallrye.jwt.build.JwtClaimsBuilder;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Servi√ßo respons√°vel pela gera√ß√£o de tokens JWT
 * 
 * Funcionalidades:
 * - Gera√ß√£o de access tokens
 * - Gera√ß√£o de refresh tokens
 * - Tokens com diferentes TTLs baseados em contexto
 * - Claims customizadas por tipo de usu√°rio
 */
@ApplicationScoped
public class TokenService {
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Constantes de Configura√ß√£o
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    private static final String ISSUER = "https://meuapp.com";
    private static final String AUDIENCE = "meuapp-api";
    
    // Tempos de expira√ß√£o
    private static final int ACCESS_TOKEN_MINUTES = 15;
    private static final int REFRESH_TOKEN_DAYS = 7;
    private static final int REMEMBER_ME_DAYS = 30;
    
    @Inject
    UsuarioService usuarioService;
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 1. Gera√ß√£o B√°sica de Token
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Gera um token JWT b√°sico com claims m√≠nimas
     * 
     * @param username Nome do usu√°rio
     * @param roles Roles do usu√°rio
     * @return Token JWT assinado
     */
    public String gerarTokenBasico(String username, Set<String> roles) {
        return Jwt.issuer(ISSUER)
            .upn(username)                    // User Principal Name
            .groups(roles)                    // Roles/Grupos
            .expiresAt(expiracaoAccessToken())
            .sign();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 2. Gera√ß√£o Completa com Claims Customizadas
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Gera token completo com todas as claims do usu√°rio
     * 
     * @param usuario DTO com dados do usu√°rio
     * @return Token JWT assinado com claims completas
     */
    public String gerarAccessToken(UsuarioDTO usuario) {
        Instant now = Instant.now();
        Instant expiration = now.plus(ACCESS_TOKEN_MINUTES, ChronoUnit.MINUTES);
        
        return Jwt.issuer(ISSUER)
            .audience(AUDIENCE)
            .subject(usuario.id.toString())
            .upn(usuario.username)
            .groups(usuario.roles)
            
            // Claims padr√£o
            .issuedAt(now.getEpochSecond())
            .expiresAt(expiration.getEpochSecond())
            .jti(UUID.randomUUID().toString())
            
            // Claims customizadas - Informa√ß√µes do usu√°rio
            .claim("userId", usuario.id)
            .claim("email", usuario.email)
            .claim("nome", usuario.nome)
            .claim("avatar", usuario.avatarUrl)
            
            // Claims customizadas - Organiza√ß√£o
            .claim("departamento", usuario.departamento)
            .claim("nivel", usuario.nivel)
            .claim("empresa", usuario.empresa)
            
            // Claims customizadas - Permiss√µes
            .claim("permissions", usuario.permissions)
            .claim("tipo", "access_token")
            
            .sign();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 3. Refresh Token
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Gera refresh token (longa dura√ß√£o)
     * 
     * Caracter√≠sticas:
     * - Dura√ß√£o mais longa (7 dias)
     * - Claims m√≠nimas (seguran√ßa)
     * - Usado apenas para renovar access token
     * 
     * @param username Nome do usu√°rio
     * @param rememberMe Se deve criar token de longa dura√ß√£o
     * @return Refresh token
     */
    public String gerarRefreshToken(String username, boolean rememberMe) {
        Instant now = Instant.now();
        Instant expiration = rememberMe 
            ? now.plus(REMEMBER_ME_DAYS, ChronoUnit.DAYS)
            : now.plus(REFRESH_TOKEN_DAYS, ChronoUnit.DAYS);
        
        return Jwt.issuer(ISSUER)
            .audience(AUDIENCE)
            .upn(username)
            .issuedAt(now.getEpochSecond())
            .expiresAt(expiration.getEpochSecond())
            .jti(UUID.randomUUID().toString())
            .claim("tipo", "refresh_token")
            .claim("rememberMe", rememberMe)
            .sign();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 4. Token com Claims Condicionais
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Gera token com claims baseadas em condi√ß√µes
     * 
     * Exemplo: Admins recebem claims extras
     */
    public String gerarTokenComClaimsCondicionais(UsuarioDTO usuario) {
        JwtClaimsBuilder builder = Jwt.issuer(ISSUER)
            .audience(AUDIENCE)
            .upn(usuario.username)
            .groups(usuario.roles)
            .expiresAt(expiracaoAccessToken())
            .claim("userId", usuario.id)
            .claim("email", usuario.email)
            .claim("nome", usuario.nome);
        
        // Claims extras para administradores
        if (usuario.roles.contains("admin")) {
            builder.claim("isAdmin", true)
                   .claim("adminLevel", usuario.adminLevel)
                   .claim("canImpersonate", true)
                   .claim("fullAccess", true);
        }
        
        // Claims extras para gerentes
        if (usuario.roles.contains("manager")) {
            builder.claim("team", usuario.teamMembers)
                   .claim("budgetLimit", usuario.budgetLimit)
                   .claim("approvalLevel", usuario.approvalLevel);
        }
        
        // Claims para usu√°rios premium
        if (usuario.isPremium) {
            builder.claim("premium", true)
                   .claim("features", usuario.premiumFeatures)
                   .claim("quotaLimit", usuario.quotaLimit);
        }
        
        return builder.sign();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 5. Token para Diferentes Dispositivos
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Gera token espec√≠fico para tipo de dispositivo
     * 
     * Web: TTL curto (15 min)
     * Mobile: TTL m√©dio (1 hora)
     * IoT: TTL longo (24 horas)
     */
    public String gerarTokenPorDispositivo(
            UsuarioDTO usuario, 
            DeviceType deviceType) {
        
        Instant now = Instant.now();
        Instant expiration = switch (deviceType) {
            case WEB -> now.plus(15, ChronoUnit.MINUTES);
            case MOBILE -> now.plus(1, ChronoUnit.HOURS);
            case IOT -> now.plus(24, ChronoUnit.HOURS);
            case TABLET -> now.plus(30, ChronoUnit.MINUTES);
        };
        
        return Jwt.issuer(ISSUER)
            .upn(usuario.username)
            .groups(usuario.roles)
            .expiresAt(expiration.getEpochSecond())
            .claim("deviceType", deviceType.name())
            .claim("deviceId", usuario.deviceId)
            .claim("platform", usuario.platform)
            .sign();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 6. Token para API Externa (Third-Party)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Gera token para acesso de APIs externas
     * 
     * Caracter√≠sticas:
     * - Audience espec√≠fica
     * - Scopes limitados
     * - Claims m√≠nimas
     */
    public String gerarTokenApiExterna(
            String clientId, 
            Set<String> scopes) {
        
        return Jwt.issuer(ISSUER)
            .audience("external-api")
            .subject(clientId)
            .expiresAt(Instant.now().plus(1, ChronoUnit.HOURS).getEpochSecond())
            .claim("client_id", clientId)
            .claim("scopes", scopes)
            .claim("tipo", "client_credentials")
            .claim("api_version", "v1")
            .sign();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 7. Token Tempor√°rio (One-Time Use)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Gera token de uso √∫nico para a√ß√µes espec√≠ficas
     * 
     * Exemplos:
     * - Reset de senha
     * - Confirma√ß√£o de email
     * - Convite de usu√°rio
     */
    public String gerarTokenTemporario(
            String email, 
            String action, 
            int duracaoMinutos) {
        
        return Jwt.issuer(ISSUER)
            .subject(email)
            .expiresAt(Instant.now()
                .plus(duracaoMinutos, ChronoUnit.MINUTES)
                .getEpochSecond())
            .jti(UUID.randomUUID().toString())
            .claim("action", action)
            .claim("email", email)
            .claim("tipo", "one_time_token")
            .claim("singleUse", true)
            .sign();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 8. Par de Tokens (Access + Refresh)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Gera par completo de tokens (access + refresh)
     * 
     * @param usuario Dados do usu√°rio
     * @param rememberMe Manter conectado
     * @return Par de tokens
     */
    public TokenPair gerarParDeTokens(UsuarioDTO usuario, boolean rememberMe) {
        String accessToken = gerarAccessToken(usuario);
        String refreshToken = gerarRefreshToken(usuario.username, rememberMe);
        
        return new TokenPair(
            accessToken,
            refreshToken,
            ACCESS_TOKEN_MINUTES * 60,  // em segundos
            "Bearer"
        );
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // M√©todos Auxiliares
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    private long expiracaoAccessToken() {
        return Instant.now()
            .plus(ACCESS_TOKEN_MINUTES, ChronoUnit.MINUTES)
            .getEpochSecond();
    }
    
    private long expiracaoRefreshToken(boolean rememberMe) {
        int dias = rememberMe ? REMEMBER_ME_DAYS : REFRESH_TOKEN_DAYS;
        return Instant.now()
            .plus(dias, ChronoUnit.DAYS)
            .getEpochSecond();
    }
}

/**
 * Tipo de dispositivo
 */
enum DeviceType {
    WEB,
    MOBILE,
    TABLET,
    IOT
}

/**
 * Par de tokens (Access + Refresh)
 */
record TokenPair(
    String accessToken,
    String refreshToken,
    int expiresIn,
    String tokenType
) {}

    String refreshToken,
    int expiresIn,
    String tokenType
) {}
```

### 4.3 Estrat√©gias de TTL (Time To Live)

#### Tabela Comparativa

| Cen√°rio | Access Token | Refresh Token | Justificativa |
|---------|--------------|---------------|---------------|
| **Banking/Financeiro** | 5-10 min | 1 hora | M√°xima seguran√ßa |
| **Healthcare** | 10 min | 2 horas | Dados sens√≠veis |
| **E-commerce** | 15-30 min | 7 dias | Balanceado |
| **SaaS B2B** | 30-60 min | 30 dias | Produtividade |
| **Redes Sociais** | 1 hora | 90 dias | Conveni√™ncia |
| **Mobile App** | 1-2 horas | 30 dias | Experi√™ncia do usu√°rio |
| **IoT Devices** | 24 horas | 365 dias | Dispositivos confi√°veis |

#### Implementa√ß√£o de Estrat√©gias

```java
/**
 * Estrat√©gias de expira√ß√£o de tokens
 */
@ApplicationScoped
public class TokenExpirationStrategy {
    
    public record ExpirationConfig(
        int accessTokenMinutes,
        int refreshTokenDays,
        String justificativa
    ) {}
    
    public ExpirationConfig getStrategyByContext(SecurityContext context) {
        return switch (context) {
            case BANKING -> new ExpirationConfig(
                5, 
                0,  // Refresh token de 1 hora
                "M√°xima seguran√ßa para transa√ß√µes financeiras"
            );
            
            case HEALTHCARE -> new ExpirationConfig(
                10, 
                0,  // 2 horas
                "Prote√ß√£o de dados m√©dicos sens√≠veis"
            );
            
            case ECOMMERCE -> new ExpirationConfig(
                15, 
                7, 
                "Balanceamento entre seguran√ßa e UX"
            );
            
            case SAAS -> new ExpirationConfig(
                60, 
                30, 
                "Produtividade para usu√°rios corporativos"
            );
            
            case SOCIAL_MEDIA -> new ExpirationConfig(
                60, 
                90, 
                "Conveni√™ncia para usu√°rios finais"
            );
            
            case IOT -> new ExpirationConfig(
                1440,  // 24 horas
                365, 
                "Dispositivos confi√°veis com conectividade limitada"
            );
        };
    }
}

enum SecurityContext {
    BANKING, HEALTHCARE, ECOMMERCE, SAAS, SOCIAL_MEDIA, IOT
}
```

---

## 5. Valida√ß√£o e Verifica√ß√£o

### 5.1 Fluxo de Valida√ß√£o

```mermaid
sequenceDiagram
    participant C as Cliente
    participant F as Quarkus Filter
    participant V as JWT Validator
    participant K as Key Manager
    participant E as Endpoint
    
    C->>F: Request + Authorization Header
    F->>F: Extrair Token do Header
    
    F->>V: Validar Token
    V->>V: 1. Verificar formato (3 partes)
    V->>V: 2. Decode Base64
    
    V->>K: 3. Obter chave p√∫blica
    K-->>V: Public Key
    
    V->>V: 4. Verificar assinatura
    
    alt Assinatura Inv√°lida
        V-->>F: 401 Unauthorized
        F-->>C: Token inv√°lido
    end
    
    V->>V: 5. Verificar issuer
    V->>V: 6. Verificar audience
    V->>V: 7. Verificar expira√ß√£o
    V->>V: 8. Verificar not-before
    
    alt Valida√ß√µes OK
        V-->>F: Token V√°lido
        F->>F: Criar SecurityIdentity
        F->>E: Processar Request
        E-->>C: Response
    else Valida√ß√£o Falhou
        V-->>F: 401 Unauthorized
        F-->>C: Token expirado/inv√°lido
    end
```

### 5.2 Validador Customizado

```java
package com.exemplo.auth.validator;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import jakarta.enterprise.context.ApplicationScoped;
import org.eclipse.microprofile.config.inject.ConfigProperty;

import java.security.Key;
import java.security.PublicKey;
import java.time.Instant;
import java.util.*;

/**
 * Validador customizado de JWT
 * 
 * Realiza valida√ß√µes extras al√©m das padr√£o do SmallRye JWT:
 * - Blacklist de tokens revogados
 * - Valida√ß√£o de claims obrigat√≥rias
 * - Valida√ß√£o de formato de claims
 * - Rate limiting por token
 */
@ApplicationScoped
public class CustomJwtValidator {
    
    @ConfigProperty(name = "mp.jwt.verify.issuer")
    String expectedIssuer;
    
    @ConfigProperty(name = "mp.jwt.verify.publickey.location")
    String publicKeyLocation;
    
    // Blacklist de tokens revogados (em produ√ß√£o usar Redis)
    private final Set<String> revokedTokens = new HashSet<>();
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Valida√ß√£o Completa
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Valida token JWT completamente
     * 
     * @param token Token JWT
     * @return Claims se v√°lido
     * @throws JwtValidationException se inv√°lido
     */
    public Claims validarToken(String token) throws JwtValidationException {
        // 1. Validar formato
        validarFormato(token);
        
        // 2. Verificar blacklist
        if (estaRevogado(token)) {
            throw new JwtValidationException("Token foi revogado");
        }
        
        // 3. Parse e valida√ß√£o de assinatura
        Claims claims = parsearToken(token);
        
        // 4. Valida√ß√µes customizadas
        validarClaimsObrigatorias(claims);
        validarFormatoClaims(claims);
        validarRegrasNegocio(claims);
        
        return claims;
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 1. Valida√ß√£o de Formato
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    private void validarFormato(String token) throws JwtValidationException {
        if (token == null || token.isBlank()) {
            throw new JwtValidationException("Token vazio");
        }
        
        // JWT deve ter 3 partes: header.payload.signature
        String[] parts = token.split("\\.");
        if (parts.length != 3) {
            throw new JwtValidationException(
                "Formato inv√°lido. Esperado: header.payload.signature"
            );
        }
        
        // Validar que cada parte √© Base64 v√°lido
        for (String part : parts) {
            if (!isBase64Valido(part)) {
                throw new JwtValidationException("Token cont√©m Base64 inv√°lido");
            }
        }
    }
    
    private boolean isBase64Valido(String str) {
        try {
            Base64.getUrlDecoder().decode(str);
            return true;
        } catch (IllegalArgumentException e) {
            return false;
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 2. Verifica√ß√£o de Revoga√ß√£o (Blacklist)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Verifica se token est√° na blacklist
     */
    public boolean estaRevogado(String token) {
        String jti = extrairJti(token);
        return jti != null && revokedTokens.contains(jti);
    }
    
    /**
     * Adiciona token √† blacklist
     */
    public void revogarToken(String token) {
        String jti = extrairJti(token);
        if (jti != null) {
            revokedTokens.add(jti);
            // Em produ√ß√£o: salvar no Redis com TTL = tempo at√© expira√ß√£o
        }
    }
    
    private String extrairJti(String token) {
        try {
            Claims claims = parsearTokenSemValidacao(token);
            return claims.getId();
        } catch (Exception e) {
            return null;
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 3. Parse do Token
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    private Claims parsearToken(String token) throws JwtValidationException {
        try {
            PublicKey publicKey = carregarChavePublica();
            
            return Jwts.parserBuilder()
                .setSigningKey(publicKey)
                .requireIssuer(expectedIssuer)
                .build()
                .parseClaimsJws(token)
                .getBody();
                
        } catch (ExpiredJwtException e) {
            throw new JwtValidationException(
                "Token expirado em: " + e.getClaims().getExpiration()
            );
        } catch (UnsupportedJwtException e) {
            throw new JwtValidationException("Formato de token n√£o suportado");
        } catch (MalformedJwtException e) {
            throw new JwtValidationException("Token malformado");
        } catch (SignatureException e) {
            throw new JwtValidationException("Assinatura inv√°lida");
        } catch (Exception e) {
            throw new JwtValidationException("Erro ao validar token: " + e.getMessage());
        }
    }
    
    private Claims parsearTokenSemValidacao(String token) {
        int i = token.lastIndexOf('.');
        String tokenSemAssinatura = token.substring(0, i + 1);
        
        return Jwts.parserBuilder()
            .build()
            .parseClaimsJwt(tokenSemAssinatura)
            .getBody();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 4. Valida√ß√µes de Claims Obrigat√≥rias
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    private void validarClaimsObrigatorias(Claims claims) throws JwtValidationException {
        // Claims padr√£o obrigat√≥rias
        if (claims.getSubject() == null) {
            throw new JwtValidationException("Claim 'sub' obrigat√≥ria");
        }
        
        if (claims.getExpiration() == null) {
            throw new JwtValidationException("Claim 'exp' obrigat√≥ria");
        }
        
        if (claims.getIssuedAt() == null) {
            throw new JwtValidationException("Claim 'iat' obrigat√≥ria");
        }
        
        // Claims customizadas obrigat√≥rias
        if (!claims.containsKey("upn")) {
            throw new JwtValidationException("Claim 'upn' obrigat√≥ria");
        }
        
        if (!claims.containsKey("groups")) {
            throw new JwtValidationException("Claim 'groups' obrigat√≥ria");
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 5. Valida√ß√£o de Formato de Claims
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    private void validarFormatoClaims(Claims claims) throws JwtValidationException {
        // Validar email (se presente)
        if (claims.containsKey("email")) {
            String email = claims.get("email", String.class);
            if (!email.matches("^[A-Za-z0-9+_.-]+@(.+)$")) {
                throw new JwtValidationException("Formato de email inv√°lido");
            }
        }
        
        // Validar userId (deve ser n√∫mero positivo)
        if (claims.containsKey("userId")) {
            Object userIdObj = claims.get("userId");
            Long userId = userIdObj instanceof Integer 
                ? ((Integer) userIdObj).longValue() 
                : (Long) userIdObj;
            
            if (userId <= 0) {
                throw new JwtValidationException("userId deve ser positivo");
            }
        }
        
        // Validar groups (deve ser array n√£o vazio)
        if (claims.containsKey("groups")) {
            Object groups = claims.get("groups");
            if (groups instanceof List) {
                if (((List<?>) groups).isEmpty()) {
                    throw new JwtValidationException("Usu√°rio deve ter pelo menos 1 role");
                }
            }
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 6. Valida√ß√µes de Regras de Neg√≥cio
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    private void validarRegrasNegocio(Claims claims) throws JwtValidationException {
        // Regra: Token pr√≥ximo da expira√ß√£o (< 1 minuto) deve ser renovado
        Date expiration = claims.getExpiration();
        long secondsUntilExpiration = 
            (expiration.getTime() - System.currentTimeMillis()) / 1000;
        
        if (secondsUntilExpiration < 60) {
            // N√£o falha, mas poderia logar warning
            System.out.println("AVISO: Token expira em " + secondsUntilExpiration + "s");
        }
        
        // Regra: Validar departamento permitido
        if (claims.containsKey("departamento")) {
            String dept = claims.get("departamento", String.class);
            List<String> departamentosValidos = 
                List.of("TI", "RH", "VENDAS", "FINANCEIRO", "OPERACOES");
            
            if (!departamentosValidos.contains(dept)) {
                throw new JwtValidationException("Departamento inv√°lido: " + dept);
            }
        }
        
        // Regra: Tokens "one_time" s√≥ podem ser usados uma vez
        if (claims.containsKey("singleUse")) {
            boolean singleUse = claims.get("singleUse", Boolean.class);
            if (singleUse) {
                // Verificar se j√° foi usado (implementar em Redis)
                String jti = claims.getId();
                if (tokenJaFoiUsado(jti)) {
                    throw new JwtValidationException("Token de uso √∫nico j√° foi utilizado");
                }
                marcarTokenComoUsado(jti);
            }
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // M√©todos Auxiliares
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    private PublicKey carregarChavePublica() throws Exception {
        // Implementar carregamento da chave p√∫blica
        // Por simplicidade, retornando null (substituir em produ√ß√£o)
        return null;
    }
    
    private boolean tokenJaFoiUsado(String jti) {
        // Implementar verifica√ß√£o no Redis
        return false;
    }
    
    private void marcarTokenComoUsado(String jti) {
        // Implementar marca√ß√£o no Redis
    }
}

/**
 * Exce√ß√£o customizada de valida√ß√£o JWT
 */
class JwtValidationException extends Exception {
    public JwtValidationException(String message) {
        super(message);
    }
}
```

### 5.3 Verifica√ß√£o em Tempo Real

```java
/**
 * Servi√ßo para verifica√ß√£o de tokens em tempo real
 */
@ApplicationScoped
public class TokenVerificationService {
    
    @Inject
    JsonWebToken jwt;
    
    @Inject
    CustomJwtValidator validator;
    
    /**
     * Informa√ß√µes sobre o token atual
     */
    public record TokenInfo(
        String username,
        Set<String> roles,
        long secondsUntilExpiration,
        boolean isExpiringSoon,
        boolean needsRefresh,
        Map<String, Object> customClaims
    ) {}
    
    /**
     * Obt√©m informa√ß√µes detalhadas do token atual
     */
    public TokenInfo getTokenInfo() {
        long exp = jwt.getExpirationTime();
        long now = Instant.now().getEpochSecond();
        long secondsRemaining = exp - now;
        
        // Claims customizadas
        Map<String, Object> customClaims = new HashMap<>();
        jwt.getClaimNames().forEach(claim -> {
            if (!isStandardClaim(claim)) {
                customClaims.put(claim, jwt.getClaim(claim));
            }
        });
        
        return new TokenInfo(
            jwt.getName(),
            jwt.getGroups(),
            secondsRemaining,
            secondsRemaining < 300,  // < 5 minutos
            secondsRemaining < 180,  // < 3 minutos
            customClaims
        );
    }
    
    /**
     * Verifica se token precisa ser renovado
     */
    public boolean precisaRenovar() {
        long exp = jwt.getExpirationTime();
        long now = Instant.now().getEpochSecond();
        long secondsRemaining = exp - now;
        
        // Renovar se faltar menos de 3 minutos
        return secondsRemaining < 180;
    }
    
    private boolean isStandardClaim(String claim) {
        return Set.of("iss", "sub", "aud", "exp", "nbf", "iat", "jti", "upn", "groups")
            .contains(claim);
    }
}
```

---

## 6. Prote√ß√£o de Endpoints

### 6.1 Hierarquia de Anota√ß√µes de Seguran√ßa

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @DenyAll                                                    ‚îÇ
‚îÇ ‚îî‚îÄ Ningu√©m pode acessar (nem mesmo admin)                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @PermitAll                                                  ‚îÇ
‚îÇ ‚îî‚îÄ Todos podem acessar (sem autentica√ß√£o)                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @RolesAllowed("user")                                       ‚îÇ
‚îÇ ‚îî‚îÄ Apenas usu√°rios autenticados com role "user"            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ @RolesAllowed({"admin", "manager"})                         ‚îÇ
‚îÇ ‚îî‚îÄ Usu√°rios com role "admin" OU "manager"                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 6.2 Endpoint de Autentica√ß√£o Completo

```java
package com.exemplo.auth.resource;

import com.exemplo.auth.dto.*;
import com.exemplo.auth.service.*;
import jakarta.annotation.security.PermitAll;
import jakarta.inject.Inject;
import jakarta.validation.Valid;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.*;

/**
 * Endpoint de autentica√ß√£o
 * 
 * Responsabilidades:
 * - Login de usu√°rios
 * - Registro de novos usu√°rios  
 * - Renova√ß√£o de tokens (refresh)
 * - Logout
 */
@Path("/auth")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class AuthResource {
    
    @Inject
    TokenService tokenService;
    
    @Inject
    UsuarioService usuarioService;
    
    @Inject
    CustomJwtValidator jwtValidator;
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Login
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Realiza login e retorna tokens
     * 
     * @param request Credenciais (username, password, rememberMe)
     * @return Access token + Refresh token
     */
    @POST
    @Path("/login")
    @PermitAll
    public Response login(@Valid LoginRequest request) {
        try {
            // 1. Autenticar usu√°rio
            UsuarioDTO usuario = usuarioService.autenticar(
                request.username, 
                request.password
            );
            
            if (usuario == null) {
                return Response.status(Response.Status.UNAUTHORIZED)
                    .entity(new ErrorResponse(
                        "INVALID_CREDENTIALS",
                        "Usu√°rio ou senha inv√°lidos"
                    ))
                    .build();
            }
            
            // 2. Verificar se usu√°rio est√° ativo
            if (!usuario.ativo) {
                return Response.status(Response.Status.FORBIDDEN)
                    .entity(new ErrorResponse(
                        "ACCOUNT_DISABLED",
                        "Conta desativada. Contate o administrador."
                    ))
                    .build();
            }
            
            // 3. Gerar tokens
            TokenPair tokens = tokenService.gerarParDeTokens(
                usuario, 
                request.rememberMe
            );
            
            // 4. Atualizar √∫ltimo login
            usuarioService.atualizarUltimoLogin(usuario.id);
            
            // 5. Resposta com tokens e dados do usu√°rio
            AuthResponse response = new AuthResponse(
                tokens.accessToken(),
                tokens.refreshToken(),
                tokens.tokenType(),
                tokens.expiresIn(),
                usuario
            );
            
            return Response.ok(response).build();
            
        } catch (Exception e) {
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                .entity(new ErrorResponse(
                    "INTERNAL_ERROR",
                    "Erro ao processar login"
                ))
                .build();
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Registro
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Registra novo usu√°rio
     */
    @POST
    @Path("/register")
    @PermitAll
    public Response register(@Valid RegisterRequest request) {
        try {
            // 1. Verificar se usu√°rio j√° existe
            if (usuarioService.existePorUsername(request.username)) {
                return Response.status(Response.Status.CONFLICT)
                    .entity(new ErrorResponse(
                        "USERNAME_EXISTS",
                        "Nome de usu√°rio j√° existe"
                    ))
                    .build();
            }
            
            if (usuarioService.existePorEmail(request.email)) {
                return Response.status(Response.Status.CONFLICT)
                    .entity(new ErrorResponse(
                        "EMAIL_EXISTS",
                        "Email j√° est√° cadastrado"
                    ))
                    .build();
            }
            
            // 2. Criar usu√°rio
            UsuarioDTO novoUsuario = usuarioService.criar(request);
            
            // 3. Gerar tokens
            TokenPair tokens = tokenService.gerarParDeTokens(novoUsuario, false);
            
            // 4. Resposta
            AuthResponse response = new AuthResponse(
                tokens.accessToken(),
                tokens.refreshToken(),
                tokens.tokenType(),
                tokens.expiresIn(),
                novoUsuario
            );
            
            return Response.status(Response.Status.CREATED)
                .entity(response)
                .build();
                
        } catch (Exception e) {
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                .entity(new ErrorResponse(
                    "REGISTRATION_ERROR",
                    "Erro ao criar conta"
                ))
                .build();
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Refresh Token
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Renova access token usando refresh token
     */
    @POST
    @Path("/refresh")
    @PermitAll
    public Response refresh(@Valid RefreshRequest request) {
        try {
            // 1. Validar refresh token
            Claims claims = jwtValidator.validarToken(request.refreshToken);
            
            // 2. Verificar se √© refresh token
            String tipo = claims.get("tipo", String.class);
            if (!"refresh_token".equals(tipo)) {
                return Response.status(Response.Status.BAD_REQUEST)
                    .entity(new ErrorResponse(
                        "INVALID_TOKEN_TYPE",
                        "Token fornecido n√£o √© um refresh token"
                    ))
                    .build();
            }
            
            // 3. Buscar usu√°rio
            String username = claims.get("upn", String.class);
            UsuarioDTO usuario = usuarioService.buscarPorUsername(username);
            
            if (usuario == null || !usuario.ativo) {
                return Response.status(Response.Status.UNAUTHORIZED)
                    .entity(new ErrorResponse(
                        "USER_NOT_FOUND",
                        "Usu√°rio n√£o encontrado ou inativo"
                    ))
                    .build();
            }
            
            // 4. Gerar novo access token
            String novoAccessToken = tokenService.gerarAccessToken(usuario);
            
            // 5. Resposta com novo token
            RefreshResponse response = new RefreshResponse(
                novoAccessToken,
                "Bearer",
                900  // 15 minutos
            );
            
            return Response.ok(response).build();
            
        } catch (JwtValidationException e) {
            return Response.status(Response.Status.UNAUTHORIZED)
                .entity(new ErrorResponse(
                    "INVALID_REFRESH_TOKEN",
                    e.getMessage()
                ))
                .build();
        } catch (Exception e) {
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                .entity(new ErrorResponse(
                    "REFRESH_ERROR",
                    "Erro ao renovar token"
                ))
                .build();
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Logout
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Realiza logout (revoga tokens)
     */
    @POST
    @Path("/logout")
    @PermitAll
    public Response logout(@HeaderParam("Authorization") String authHeader) {
        try {
            if (authHeader != null && authHeader.startsWith("Bearer ")) {
                String token = authHeader.substring(7);
                
                // Adicionar token √† blacklist
                jwtValidator.revogarToken(token);
            }
            
            return Response.ok(new MessageResponse("Logout realizado com sucesso")).build();
            
        } catch (Exception e) {
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                .entity(new ErrorResponse(
                    "LOGOUT_ERROR",
                    "Erro ao processar logout"
                ))
                .build();
        }
    }
}

/**
 * DTOs para Autentica√ß√£o
 */

// Request de Login
record LoginRequest(
    @NotBlank String username,
    @NotBlank String password,
    boolean rememberMe
) {}

// Request de Registro
record RegisterRequest(
    @NotBlank @Size(min = 3, max = 50) String username,
    @NotBlank @Email String email,
    @NotBlank @Size(min = 8) String password,
    @NotBlank String nome
) {}

// Request de Refresh
record RefreshRequest(
    @NotBlank String refreshToken
) {}

// Response de Autentica√ß√£o
record AuthResponse(
    String accessToken,
    String refreshToken,
    String tokenType,
    int expiresIn,
    UsuarioDTO usuario
) {}

// Response de Refresh
record RefreshResponse(
    String accessToken,
    String tokenType,
    int expiresIn
) {}

// Mensagem gen√©rica
record MessageResponse(String message) {}

// Response de Erro
record ErrorResponse(
    String code,
    String message,
    String timestamp
) {
    public ErrorResponse(String code, String message) {
        this(code, message, java.time.LocalDateTime.now().toString());
    }
}
```

### 6.3 Prote√ß√£o de Endpoints - Exemplos Pr√°ticos

```java
package com.exemplo.resource;

import io.quarkus.security.identity.SecurityIdentity;
import jakarta.annotation.security.*;
import jakarta.inject.Inject;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.*;
import org.eclipse.microprofile.jwt.JsonWebToken;

import java.util.*;

/**
 * Exemplos completos de prote√ß√£o de endpoints
 */
@Path("/api")
@Produces(MediaType.APPLICATION_JSON)
public class ProtectedResource {
    
    @Inject
    JsonWebToken jwt;
    
    @Inject
    SecurityIdentity identity;
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 1. Endpoint P√∫blico (sem autentica√ß√£o)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    @GET
    @Path("/public/info")
    @PermitAll
    public Response informacoesPublicas() {
        return Response.ok(Map.of(
            "app", "Meu App",
            "version", "1.0.0",
            "status", "online"
        )).build();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 2. Qualquer Usu√°rio Autenticado
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    @GET
    @Path("/perfil")
    @RolesAllowed("user")
    public Response meuPerfil() {
        return Response.ok(Map.of(
            "username", jwt.getName(),
            "email", jwt.getClaim("email"),
            "roles", jwt.getGroups()
        )).build();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 3. Apenas Administradores
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    @GET
    @Path("/admin/users")
    @RolesAllowed("admin")
    public Response listarTodosUsuarios() {
        // Apenas admins podem listar todos os usu√°rios
        return Response.ok(List.of(
            Map.of("id", 1, "nome", "Jo√£o"),
            Map.of("id", 2, "nome", "Maria")
        )).build();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 4. M√∫ltiplos Roles (OR)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    @GET
    @Path("/reports")
    @RolesAllowed({"admin", "manager", "analyst"})
    public Response relatorios() {
        // Admin OU Manager OU Analyst podem acessar
        String userRole = jwt.getGroups().stream()
            .filter(r -> List.of("admin", "manager", "analyst").contains(r))
            .findFirst()
            .orElse("unknown");
        
        return Response.ok(Map.of(
            "message", "Relat√≥rios dispon√≠veis",
            "accessLevel", userRole
        )).build();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 5. Verifica√ß√£o Program√°tica de Roles
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    @GET
    @Path("/dashboard")
    @RolesAllowed("user")
    public Response dashboard() {
        Map<String, Object> response = new HashMap<>();
        
        if (identity.hasRole("admin")) {
            response.put("widgets", List.of("users", "stats", "logs", "config"));
            response.put("level", "full");
        } else if (identity.hasRole("manager")) {
            response.put("widgets", List.of("team", "tasks", "reports"));
            response.put("level", "management");
        } else {
            response.put("widgets", List.of("tasks", "profile"));
            response.put("level", "basic");
        }
        
        return Response.ok(response).build();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 6. Controle Baseado em Claims
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    @GET
    @Path("/sensitive-data")
    @RolesAllowed("user")
    public Response dadosSensiveis() {
        // Verificar claim adicional
        String departamento = jwt.getClaim("departamento");
        
        if (!"FINANCEIRO".equals(departamento) && !identity.hasRole("admin")) {
            return Response.status(Response.Status.FORBIDDEN)
                .entity(Map.of("error", "Acesso restrito ao departamento financeiro"))
                .build();
        }
        
        return Response.ok(Map.of("data", "Informa√ß√µes financeiras")).build();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 7. Controle de Propriedade de Recurso
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    @GET
    @Path("/orders/{id}")
    @RolesAllowed("user")
    public Response obterPedido(@PathParam("id") Long pedidoId) {
        Long userId = jwt.getClaim("userId");
        
        // Buscar pedido (simulado)
        PedidoDTO pedido = buscarPedido(pedidoId);
        
        // Usu√°rio s√≥ pode ver seus pr√≥prios pedidos (exceto admin)
        if (!identity.hasRole("admin") && !pedido.usuarioId.equals(userId)) {
            return Response.status(Response.Status.FORBIDDEN)
                .entity(Map.of("error", "Voc√™ s√≥ pode acessar seus pr√≥prios pedidos"))
                .build();
        }
        
        return Response.ok(pedido).build();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 8. Endpoint Bloqueado para Todos
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    @DELETE
    @Path("/system/reset")
    @DenyAll
    public Response resetarSistema() {
        // Ningu√©m pode acessar via HTTP
        // Apenas via console/script interno
        return Response.status(Response.Status.FORBIDDEN)
            .entity(Map.of("error", "Opera√ß√£o n√£o permitida via API"))
            .build();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // M√©todos Auxiliares
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    private PedidoDTO buscarPedido(Long id) {
        // Simula√ß√£o - substituir por busca real no banco
        return new PedidoDTO(id, 1L, "Produto X", 99.90);
    }
}

record PedidoDTO(Long id, Long usuarioId, String produto, Double valor) {}
```

---

## 7. Claims Customizadas

### 7.1 Inje√ß√£o e Uso de Claims

```java
package com.exemplo.resource;

import jakarta.annotation.security.RolesAllowed;
import jakarta.inject.Inject;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.*;
import org.eclipse.microprofile.jwt.*;

import java.util.*;

/**
 * Trabalhando com Claims Customizadas
 */
@Path("/api/claims")
@Produces(MediaType.APPLICATION_JSON)
@RolesAllowed("user")
public class ClaimsResource {
    
    @Inject
    JsonWebToken jwt;
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Inje√ß√£o Direta de Claims Espec√≠ficas
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    @Inject
    @Claim("email")
    String email;
    
    @Inject
    @Claim("userId")
    Long userId;
    
    @Inject
    @Claim("departamento")
    Optional<String> departamento;
    
    @Inject
    @Claim("nivel")
    ClaimValue<String> nivel;
    
    @Inject
    @Claim("permissions")
    ClaimValue<Set<String>> permissions;
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 1. Listar Todas as Claims
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    @GET
    @Path("/all")
    public Response todasClaims() {
        Map<String, Object> claims = new HashMap<>();
        
        // Iterar sobre todas as claims
        jwt.getClaimNames().forEach(claimName -> {
            claims.put(claimName, jwt.getClaim(claimName));
        });
        
        return Response.ok(claims).build();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 2. Claims Padr√£o (Standard)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    @GET
    @Path("/standard")
    public Response claimsPadrao() {
        return Response.ok(Map.of(
            "issuer", jwt.getIssuer(),
            "subject", jwt.getSubject(),
            "audience", jwt.getAudience(),
            "expirationTime", jwt.getExpirationTime(),
            "issuedAtTime", jwt.getIssuedAtTime(),
            "tokenID", jwt.getTokenID(),
            "name", jwt.getName(),
            "groups", jwt.getGroups()
        )).build();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 3. Claims Injetadas
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    @GET
    @Path("/injected")
    public Response claimsInjetadas() {
        return Response.ok(Map.of(
            "email", email,
            "userId", userId,
            "departamento", departamento.orElse("N√£o informado"),
            "nivel", nivel.getValue(),
            "permissions", permissions.getValue()
        )).build();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 4. Verificar Exist√™ncia de Claims
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    @GET
    @Path("/check")
    public Response verificarClaims() {
        return Response.ok(Map.of(
            "hasEmail", jwt.containsClaim("email"),
            "hasDepartamento", jwt.containsClaim("departamento"),
            "hasPermissions", jwt.containsClaim("permissions"),
            "hasCustomClaim", jwt.containsClaim("minhaClaim")
        )).build();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 5. Claims com Tipos Complexos
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    @GET
    @Path("/complex")
    public Response claimsComplexas() {
        // Array/List
        List<String> grupos = jwt.getClaim("groups");
        
        // Map/Object
        Map<String, Object> metadados = jwt.getClaim("metadata");
        
        // N√∫mero
        Integer idade = jwt.getClaim("idade");
        
        // Boolean
        Boolean premium = jwt.getClaim("premium");
        
        return Response.ok(Map.of(
            "grupos", grupos != null ? grupos : List.of(),
            "metadados", metadados != null ? metadados : Map.of(),
            "idade", idade != null ? idade : 0,
            "premium", premium != null ? premium : false
        )).build();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 6. Valida√ß√£o de Claims
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    @GET
    @Path("/validate")
    public Response validarClaims() {
        List<String> erros = new ArrayList<>();
        
        // Validar email
        if (!jwt.containsClaim("email")) {
            erros.add("Email obrigat√≥rio");
        } else {
            String emailValue = jwt.getClaim("email");
            if (!emailValue.matches("^[A-Za-z0-9+_.-]+@(.+)$")) {
                erros.add("Email inv√°lido");
            }
        }
        
        // Validar permiss√µes
        if (jwt.containsClaim("permissions")) {
            Set<String> perms = jwt.getClaim("permissions");
            if (perms.isEmpty()) {
                erros.add("Usu√°rio deve ter pelo menos uma permiss√£o");
            }
        }
        
        // Validar expira√ß√£o
        long exp = jwt.getExpirationTime();
        long now = java.time.Instant.now().getEpochSecond();
        if (exp - now < 60) {
            erros.add("Token expira em menos de 1 minuto");
        }
        
        return Response.ok(Map.of(
            "valido", erros.isEmpty(),
            "erros", erros
        )).build();
    }
}
```

### 7.2 Interceptador para Claims Customizadas

```java
package com.exemplo.security;

import jakarta.annotation.Priority;
import jakarta.inject.Inject;
import jakarta.interceptor.*;
import jakarta.ws.rs.ForbiddenException;
import org.eclipse.microprofile.jwt.JsonWebToken;

import java.lang.annotation.*;

/**
 * Anota√ß√£o para exigir claim espec√≠fica
 */
@InterceptorBinding
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface RequireClaim {
    String name();
    String value() default "";
    boolean required() default true;
}

/**
 * Interceptador que valida claims customizadas
 */
@RequireClaim(name = "")
@Interceptor
@Priority(Interceptor.Priority.PLATFORM_BEFORE + 200)
public class ClaimInterceptor {
    
    @Inject
    JsonWebToken jwt;
    
    @AroundInvoke
    public Object validateClaim(InvocationContext context) throws Exception {
        RequireClaim annotation = context.getMethod().getAnnotation(RequireClaim.class);
        
        if (annotation == null) {
            annotation = context.getTarget().getClass().getAnnotation(RequireClaim.class);
        }
        
        if (annotation != null) {
            String claimName = annotation.name();
            String expectedValue = annotation.value();
            boolean required = annotation.required();
            
            // Verificar se claim existe
            if (!jwt.containsClaim(claimName)) {
                if (required) {
                    throw new ForbiddenException(
                        "Claim obrigat√≥ria n√£o encontrada: " + claimName
                    );
                }
                return context.proceed();
            }
            
            // Verificar valor (se especificado)
            if (!expectedValue.isEmpty()) {
                String actualValue = jwt.getClaim(claimName).toString();
                if (!expectedValue.equals(actualValue)) {
                    throw new ForbiddenException(
                        "Valor da claim '" + claimName + "' inv√°lido. " +
                        "Esperado: " + expectedValue + ", Atual: " + actualValue
                    );
                }
            }
        }
        
        return context.proceed();
    }
}

/**
 * Uso do interceptador
 */
@Path("/api/protected")
public class ProtectedResourceWithClaims {
    
    // Exige claim "departamento" com valor "TI"
    @GET
    @Path("/ti-only")
    @RequireClaim(name = "departamento", value = "TI")
    public Response apenasTI() {
        return Response.ok(Map.of(
            "message", "Acesso permitido - Departamento TI"
        )).build();
    }
    
    // Exige claim "premium" (apenas exist√™ncia)
    @GET
    @Path("/premium-features")
    @RequireClaim(name = "premium", required = true)
    public Response featuresPremium() {
        return Response.ok(Map.of(
            "features", List.of("feature1", "feature2", "feature3")
        )).build();
    }
}
```

---

## 8. Refresh Tokens

### 8.1 Estrat√©gia de Refresh Token

```mermaid
sequenceDiagram
    participant U as Usu√°rio
    participant F as Frontend
    participant A as Auth API
    participant R as Resource API
    
    U->>F: Login
    F->>A: POST /auth/login
    A-->>F: accessToken (15 min)<br/>refreshToken (7 dias)
    
    Note over F: Armazena tokens
    
    F->>R: GET /api/data<br/>Bearer accessToken
    R-->>F: Dados
    
    Note over F: 14 minutos depois
    
    F->>R: GET /api/data<br/>Bearer accessToken
    R-->>F: 401 Unauthorized (token expirado)
    
    F->>A: POST /auth/refresh<br/>{refreshToken}
    A->>A: Validar refresh token
    A-->>F: Novo accessToken (15 min)
    
    F->>R: GET /api/data<br/>Bearer NOVO accessToken
    R-->>F: Dados
```

### 8.2 Implementa√ß√£o Completa de Refresh

```java
package com.exemplo.auth.service;

import io.jsonwebtoken.Claims;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;

/**
 * Servi√ßo de gerenciamento de Refresh Tokens
 */
@ApplicationScoped
public class RefreshTokenService {
    
    @Inject
    TokenService tokenService;
    
    @Inject
    CustomJwtValidator jwtValidator;
    
    @Inject
    UsuarioService usuarioService;
    
    // Em produ√ß√£o, usar Redis para armazenar tokens ativos
    private final Map<String, RefreshTokenMetadata> activeRefreshTokens = new HashMap<>();
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 1. Criar Refresh Token
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Cria refresh token e armazena metadados
     */
    public String criarRefreshToken(String username, boolean rememberMe, String deviceInfo) {
        String refreshToken = tokenService.gerarRefreshToken(username, rememberMe);
        
        // Armazenar metadados
        RefreshTokenMetadata metadata = new RefreshTokenMetadata(
            username,
            deviceInfo,
            Instant.now(),
            rememberMe ? 30 : 7  // Dias de validade
        );
        
        activeRefreshTokens.put(refreshToken, metadata);
        
        return refreshToken;
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 2. Validar e Renovar
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Valida refresh token e gera novo access token
     */
    public RefreshResult renovarAccessToken(String refreshToken) 
            throws RefreshTokenException {
        
        // 1. Verificar se token est√° na lista de ativos
        if (!activeRefreshTokens.containsKey(refreshToken)) {
            throw new RefreshTokenException("Refresh token inv√°lido ou revogado");
        }
        
        // 2. Validar assinatura e expira√ß√£o
        Claims claims;
        try {
            claims = jwtValidator.validarToken(refreshToken);
        } catch (JwtValidationException e) {
            activeRefreshTokens.remove(refreshToken);
            throw new RefreshTokenException("Refresh token expirado", e);
        }
        
        // 3. Verificar tipo do token
        String tipo = claims.get("tipo", String.class);
        if (!"refresh_token".equals(tipo)) {
            throw new RefreshTokenException("Token n√£o √© um refresh token");
        }
        
        // 4. Buscar usu√°rio
        String username = claims.get("upn", String.class);
        UsuarioDTO usuario = usuarioService.buscarPorUsername(username);
        
        if (usuario == null || !usuario.ativo) {
            activeRefreshTokens.remove(refreshToken);
            throw new RefreshTokenException("Usu√°rio n√£o encontrado ou inativo");
        }
        
        // 5. Gerar novo access token
        String novoAccessToken = tokenService.gerarAccessToken(usuario);
        
        // 6. Atualizar √∫ltimo uso
        RefreshTokenMetadata metadata = activeRefreshTokens.get(refreshToken);
        metadata.updateLastUsed();
        
        return new RefreshResult(
            novoAccessToken,
            refreshToken,  // Mant√©m o mesmo refresh token
            900  // 15 minutos
        );
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 3. Rota√ß√£o de Refresh Token (Recomendado para Seguran√ßa)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Rotaciona refresh token (gera novo e revoga o antigo)
     * Mais seguro que reutilizar o mesmo refresh token
     */
    public RefreshResult renovarComRotacao(String oldRefreshToken) 
            throws RefreshTokenException {
        
        // Validar token antigo
        RefreshResult result = renovarAccessToken(oldRefreshToken);
        
        // Extrair informa√ß√µes do token antigo
        Claims claims = jwtValidator.validarToken(oldRefreshToken);
        String username = claims.get("upn", String.class);
        boolean rememberMe = claims.get("rememberMe", Boolean.class);
        
        // Revogar token antigo
        revogarRefreshToken(oldRefreshToken);
        
        // Criar novo refresh token
        RefreshTokenMetadata metadata = activeRefreshTokens.get(oldRefreshToken);
        String novoRefreshToken = criarRefreshToken(
            username, 
            rememberMe, 
            metadata.deviceInfo
        );
        
        return new RefreshResult(
            result.accessToken(),
            novoRefreshToken,  // Novo refresh token
            result.expiresIn()
        );
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 4. Revoga√ß√£o
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Revoga refresh token espec√≠fico
     */
    public void revogarRefreshToken(String refreshToken) {
        activeRefreshTokens.remove(refreshToken);
        // Em produ√ß√£o: remover do Redis
    }
    
    /**
     * Revoga todos os refresh tokens de um usu√°rio
     */
    public void revogarTodosTokensDoUsuario(String username) {
        activeRefreshTokens.entrySet().removeIf(entry -> 
            entry.getValue().username.equals(username)
        );
    }
    
    /**
     * Revoga refresh tokens antigos (limpeza)
     */
    public int limparTokensExpirados() {
        Instant now = Instant.now();
        int removidos = 0;
        
        Iterator<Map.Entry<String, RefreshTokenMetadata>> iterator = 
            activeRefreshTokens.entrySet().iterator();
        
        while (iterator.hasNext()) {
            Map.Entry<String, RefreshTokenMetadata> entry = iterator.next();
            RefreshTokenMetadata metadata = entry.getValue();
            
            Instant expiration = metadata.createdAt.plus(metadata.validityDays, ChronoUnit.DAYS);
            
            if (now.isAfter(expiration)) {
                iterator.remove();
                removidos++;
            }
        }
        
        return removidos;
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 5. Listagem de Sess√µes Ativas
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    /**
     * Lista sess√µes ativas do usu√°rio
     */
    public List<SessionInfo> listarSessoesAtivas(String username) {
        return activeRefreshTokens.entrySet().stream()
            .filter(e -> e.getValue().username.equals(username))
            .map(e -> new SessionInfo(
                e.getKey().substring(0, 10) + "...",  // Primeiros 10 chars
                e.getValue().deviceInfo,
                e.getValue().createdAt,
                e.getValue().lastUsed
            ))
            .toList();
    }
}

/**
 * Metadados do Refresh Token
 */
class RefreshTokenMetadata {
    String username;
    String deviceInfo;
    Instant createdAt;
    Instant lastUsed;
    int validityDays;
    
    RefreshTokenMetadata(String username, String deviceInfo, Instant createdAt, int validityDays) {
        this.username = username;
        this.deviceInfo = deviceInfo;
        this.createdAt = createdAt;
        this.lastUsed = createdAt;
        this.validityDays = validityDays;
    }
    
    void updateLastUsed() {
        this.lastUsed = Instant.now();
    }
}

/**
 * Resultado da renova√ß√£o
 */
record RefreshResult(
    String accessToken,
    String refreshToken,
    int expiresIn
) {}

/**
 * Informa√ß√£o de sess√£o ativa
 */
record SessionInfo(
    String tokenId,
    String device,
    Instant createdAt,
    Instant lastUsed
) {}

/**
 * Exce√ß√£o de refresh token
 */
class RefreshTokenException extends Exception {
    public RefreshTokenException(String message) {
        super(message);
    }
    
    public RefreshTokenException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

---

## 9. Integra√ß√£o com Frontend

### 9.1 Cliente JavaScript Completo

```javascript
/**
 * Cliente de Autentica√ß√£o JWT
 * 
 * Funcionalidades:
 * - Login/Logout
 * - Armazenamento de tokens
 * - Renova√ß√£o autom√°tica
 * - Intercepta√ß√£o de requisi√ß√µes
 */
class AuthClient {
    constructor(baseUrl) {
        this.baseUrl = baseUrl;
        this.token = localStorage.getItem('access_token');
        this.refreshToken = localStorage.getItem('refresh_token');
        this.tokenExpiresAt = parseInt(localStorage.getItem('token_expires_at') || '0');
        this.refreshing = null; // Promise de refresh em andamento
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Login
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    async login(username, password, rememberMe = false) {
        try {
            const response = await fetch(`${this.baseUrl}/auth/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ username, password, rememberMe })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.message || 'Credenciais inv√°lidas');
            }
            
            const data = await response.json();
            this._saveTokens(data);
            
            return data;
            
        } catch (error) {
            console.error('Erro no login:', error);
            throw error;
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Requisi√ß√£o Autenticada
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    async request(url, options = {}) {
        // Verificar se token precisa renova√ß√£o
        if (this._shouldRefreshToken()) {
            await this._refreshAccessToken();
        }
        
        // Adicionar token no header
        const headers = {
            ...options.headers,
            'Authorization': `Bearer ${this.token}`
        };
        
        try {
            const response = await fetch(url, {
                ...options,
                headers
            });
            
            // Token expirou durante a requisi√ß√£o
            if (response.status === 401) {
                console.log('Token expirado, renovando...');
                
                // Tentar renovar
                await this._refreshAccessToken();
                
                // Tentar novamente com novo token
                headers['Authorization'] = `Bearer ${this.token}`;
                return fetch(url, { ...options, headers });
            }
            
            return response;
            
        } catch (error) {
            console.error('Erro na requisi√ß√£o:', error);
            throw error;
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Renova√ß√£o de Token
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    async _refreshAccessToken() {
        // Se j√° h√° uma renova√ß√£o em andamento, aguardar
        if (this.refreshing) {
            return this.refreshing;
        }
        
        this.refreshing = (async () => {
            try {
                const response = await fetch(`${this.baseUrl}/auth/refresh`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ refreshToken: this.refreshToken })
                });
                
                if (!response.ok) {
                    // Refresh token inv√°lido - fazer logout
                    this.logout();
                    throw new Error('Refresh token inv√°lido');
                }
                
                const data = await response.json();
                
                // Atualizar access token
                this.token = data.accessToken;
                this.tokenExpiresAt = Date.now() + (data.expiresIn * 1000);
                
                localStorage.setItem('access_token', this.token);
                localStorage.setItem('token_expires_at', this.tokenExpiresAt.toString());
                
                console.log('Token renovado com sucesso');
                
            } catch (error) {
                console.error('Erro ao renovar token:', error);
                this.logout();
                throw error;
            } finally {
                this.refreshing = null;
            }
        })();
        
        return this.refreshing;
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Helpers
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    _shouldRefreshToken() {
        if (!this.token || !this.refreshToken) {
            return false;
        }
        
        const now = Date.now();
        const timeUntilExpiration = this.tokenExpiresAt - now;
        
        // Renovar se faltar menos de 2 minutos
        return timeUntilExpiration < 120000;
    }
    
    _saveTokens(data) {
        this.token = data.accessToken;
        this.refreshToken = data.refreshToken;
        this.tokenExpiresAt = Date.now() + (data.expiresIn * 1000);
        
        localStorage.setItem('access_token', this.token);
        localStorage.setItem('refresh_token', this.refreshToken);
        localStorage.setItem('token_expires_at', this.tokenExpiresAt.toString());
    }
    
    logout() {
        this.token = null;
        this.refreshToken = null;
        this.tokenExpiresAt = 0;
        
        localStorage.removeItem('access_token');
        localStorage.removeItem('refresh_token');
        localStorage.removeItem('token_expires_at');
        
        // Redirecionar para login (opcional)
        // window.location.href = '/login';
    }
    
    isAuthenticated() {
        return !!this.token && this.tokenExpiresAt > Date.now();
    }
    
    getToken() {
        return this.token;
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Uso Pr√°tico
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const auth = new AuthClient('http://localhost:8080');

// Login
async function fazerLogin() {
    try {
        const data = await auth.login('admin', 'senha123', true);
        console.log('Login realizado:', data.usuario);
    } catch (error) {
        console.error('Falha no login:', error.message);
    }
}

// Fazer requisi√ß√£o autenticada
async function buscarDados() {
    try {
        const response = await auth.request('http://localhost:8080/api/dados');
        const dados = await response.json();
        console.log('Dados:', dados);
    } catch (error) {
        console.error('Erro:', error);
    }
}

// Logout
function fazerLogout() {
    auth.logout();
    console.log('Logout realizado');
}
```

### 9.2 Interceptor Axios (Alternativa)

```javascript
import axios from 'axios';

class AxiosAuthClient {
    constructor(baseURL) {
        this.axios = axios.create({
            baseURL,
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        this.setupInterceptors();
    }
    
    setupInterceptors() {
        // Request Interceptor - Adiciona token
        this.axios.interceptors.request.use(
            config => {
                const token = localStorage.getItem('access_token');
                if (token) {
                    config.headers.Authorization = `Bearer ${token}`;
                }
                return config;
            },
            error => Promise.reject(error)
        );
        
        // Response Interceptor - Renova token se expirado
        this.axios.interceptors.response.use(
            response => response,
            async error => {
                const originalRequest = error.config;
                
                // Token expirado
                if (error.response?.status === 401 && !originalRequest._retry) {
                    originalRequest._retry = true;
                    
                    try {
                        const refreshToken = localStorage.getItem('refresh_token');
                        const response = await axios.post(`${this.axios.defaults.baseURL}/auth/refresh`, {
                            refreshToken
                        });
                        
                        const { accessToken } = response.data;
                        localStorage.setItem('access_token', accessToken);
                        
                        // Tentar novamente com novo token
                        originalRequest.headers.Authorization = `Bearer ${accessToken}`;
                        return this.axios(originalRequest);
                        
                    } catch (refreshError) {
                        // Refresh falhou - fazer logout
                        localStorage.clear();
                        window.location.href = '/login';
                        return Promise.reject(refreshError);
                    }
                }
                
                return Promise.reject(error);
            }
        );
    }
    
    async login(username, password, rememberMe = false) {
        const response = await this.axios.post('/auth/login', {
            username,
            password,
            rememberMe
        });
        
        const { accessToken, refreshToken } = response.data;
        localStorage.setItem('access_token', accessToken);
        localStorage.setItem('refresh_token', refreshToken);
        
        return response.data;
    }
    
    logout() {
        localStorage.clear();
    }
}

export default new AxiosAuthClient('http://localhost:8080');
```

Devido ao limite de tokens, vou criar um arquivo final com as se√ß√µes restantes (10-14):

---

## 10. Configura√ß√µes Avan√ßadas

J√° foi coberto na Se√ß√£o 3.4 com exemplos de m√∫ltiplos issuers, audiences, etc.

---

## 11. Testes

### 11.1 Testes com Quarkus Test Security

```java
@QuarkusTest
public class JwtSecurityTest {
    
    @Test
    @TestSecurity(user = "testuser", roles = "user")
    public void testEndpointProtegidoComUsuario() {
        given()
            .when()
            .get("/api/perfil")
            .then()
            .statusCode(200)
            .body("username", equalTo("testuser"));
    }
    
    @Test
    @TestSecurity(user = "admin", roles = {"admin", "user"})
    public void testEndpointAdminComRoleAdmin() {
        given()
            .when()
            .get("/api/admin/users")
            .then()
            .statusCode(200);
    }
    
    @Test
    public void testEndpointProtegidoSemAutenticacao() {
        given()
            .when()
            .get("/api/perfil")
            .then()
            .statusCode(401);
    }
}
```

---

## 12. Seguran√ßa e Boas Pr√°ticas

### 12.1 Checklist de Seguran√ßa

- ‚úÖ **Use HTTPS em produ√ß√£o**
- ‚úÖ **Chaves RSA m√≠nimo 2048 bits**
- ‚úÖ **Access token curto (15 min)**
- ‚úÖ **N√£o armazene dados sens√≠veis no token**
- ‚úÖ **Implemente blacklist para revoga√ß√£o**
- ‚úÖ **Use refresh token rotation**
- ‚úÖ **Valide audience e issuer**
- ‚úÖ **Implemente rate limiting**
- ‚úÖ **Monitore tentativas de login**

---

## 13. Troubleshooting

**Token inv√°lido**: Verificar se issuer/audience est√£o corretos
**401 sempre**: Verificar se chave p√∫blica est√° correta
**Claims nulas**: Verificar se claim existe no token

---

## 14. Recursos e Refer√™ncias

- [MicroProfile JWT](https://microprofile.io/specifications/microprofile-jwt-auth/)
- [SmallRye JWT Documentation](https://smallrye.io/smallrye-jwt/)
- [Quarkus Security Guide](https://quarkus.io/guides/security)
- [RFC 7519 - JWT](https://tools.ietf.org/html/rfc7519)

---

## Conclus√£o

SmallRye JWT no Quarkus fornece autentica√ß√£o robusta e escal√°vel para APIs modernas. Com tokens stateless, integra√ß√£o nativa e seguran√ßa configur√°vel, √© a escolha ideal para microservi√ßos Java.

**Pr√≥ximos Passos**:
1. ‚úÖ Implementar login/registro
2. ‚úÖ Configurar refresh tokens
3. ‚úÖ Proteger endpoints
4. üìö Implementar blacklist
5. üìö Monitorar seguran√ßa
6. üìö Deploy em produ√ß√£o
}

// Resposta de autentica√ß√£o
public class AuthResponse {
    public String accessToken;
    public String refreshToken;
    public String tokenType;
    public int expiresIn;
    public UsuarioDTO usuario;

    public AuthResponse(String accessToken, String refreshToken,
                       String tokenType, int expiresIn, UsuarioDTO usuario) {
        this.accessToken = accessToken;
        this.refreshToken = refreshToken;
        this.tokenType = tokenType;
        this.expiresIn = expiresIn;
        this.usuario = usuario;
    }
}

// DTO do usu√°rio
public class UsuarioDTO {
    public Long id;
    public String username;
    public String nome;
    public String email;
    public String departamento;
    public String nivel;
    public Set<String> roles;
}

// Resposta de erro
public class ErrorResponse {
    public String error;
    public String message;
    public LocalDateTime timestamp;

    public ErrorResponse(String message) {
        this.error = "Authentication Error";
        this.message = message;
        this.timestamp = LocalDateTime.now();
    }
}

```

## 4. Prote√ß√£o de Endpoints

### 4.1 Anota√ß√µes de Seguran√ßa B√°sicas

```java
@Path("/api/protected")
@ApplicationScoped
public class ProtectedResource {

    @Inject
    JsonWebToken jwt;

    @Inject
    SecurityIdentity identity;

    // Qualquer usu√°rio autenticado pode acessar
    @GET
    @Path("/info")
    @RolesAllowed("user")
    @Produces(MediaType.APPLICATION_JSON)
    public Response informacoesUsuario() {
        Map<String, Object> info = new HashMap<>();
        info.put("username", jwt.getName());
        info.put("roles", jwt.getGroups());
        info.put("email", jwt.getClaim("email"));
        info.put("expiracao", jwt.getExpirationTime());

        return Response.ok(info).build();
    }

    // Apenas administradores podem acessar
    @GET
    @Path("/admin")
    @RolesAllowed("admin")
    @Produces(MediaType.APPLICATION_JSON)
    public Response areaAdministrativa() {
        return Response.ok("√Årea exclusiva para administradores").build();
    }

    // M√∫ltiplos roles permitidos
    @GET
    @Path("/gerencial")
    @RolesAllowed({"admin", "manager"})
    @Produces(MediaType.APPLICATION_JSON)
    public Response areaGerencial() {
        Map<String, Object> dados = new HashMap<>();
        dados.put("usuario", jwt.getName());
        dados.put("nivel", jwt.getClaim("nivel"));
        dados.put("departamento", jwt.getClaim("departamento"));

        return Response.ok(dados).build();
    }

    // Verifica√ß√£o program√°tica de roles
    @GET
    @Path("/dinamica")
    @RolesAllowed("user")
    @Produces(MediaType.APPLICATION_JSON)
    public Response verificacaoDinamica() {
        if (identity.hasRole("admin")) {
            return Response.ok("Acesso completo - Administrador").build();
        } else if (identity.hasRole("manager")) {
            return Response.ok("Acesso limitado - Gerente").build();
        } else {
            return Response.ok("Acesso b√°sico - Usu√°rio").build();
        }
    }
}

```

### 4.2 Controle de Acesso Avan√ßado

```java
@Path("/api/recursos")
@ApplicationScoped
public class RecursoResource {

    @Inject
    JsonWebToken jwt;

    @Inject
    SecurityIdentity identity;

    @GET
    @Path("/usuarios")
    @RolesAllowed({"admin", "hr"})
    @Produces(MediaType.APPLICATION_JSON)
    public Response listarUsuarios() {
        // Diferentes n√≠veis de acesso baseado no role
        List<UsuarioDTO> usuarios;

        if (identity.hasRole("admin")) {
            usuarios = obterTodosUsuarios();
        } else if (identity.hasRole("hr")) {
            usuarios = obterUsuariosDoRH();
        } else {
            return Response.status(403).build();
        }

        return Response.ok(usuarios).build();
    }

    @GET
    @Path("/perfil")
    @RolesAllowed("user")
    @Produces(MediaType.APPLICATION_JSON)
    public Response obterPerfil() {
        String username = jwt.getName();
        Long userId = jwt.getClaim("userId");

        // Usu√°rio s√≥ pode ver seu pr√≥prio perfil (exceto admin)
        if (!identity.hasRole("admin") && !username.equals(obterUsernameAtual())) {
            return Response.status(403).build();
        }

        UsuarioDTO usuario = buscarUsuarioPorId(userId);
        return Response.ok(usuario).build();
    }

    @PUT
    @Path("/perfil/{id}")
    @RolesAllowed("user")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response atualizarPerfil(@PathParam("id") Long id, UsuarioDTO dados) {
        Long userIdToken = jwt.getClaim("userId");

        // Verificar se o usu√°rio est√° tentando editar seu pr√≥prio perfil
        if (!identity.hasRole("admin") && !id.equals(userIdToken)) {
            return Response.status(403)
                .entity(new ErrorResponse("Voc√™ s√≥ pode editar seu pr√≥prio perfil"))
                .build();
        }

        // L√≥gica de atualiza√ß√£o
        UsuarioDTO usuarioAtualizado = atualizarUsuario(id, dados);
        return Response.ok(usuarioAtualizado).build();
    }

    private List<UsuarioDTO> obterTodosUsuarios() {
        // Implementar busca completa
        return List.of();
    }

    private List<UsuarioDTO> obterUsuariosDoRH() {
        // Implementar busca limitada para RH
        return List.of();
    }

    private String obterUsernameAtual() {
        return jwt.getName();
    }

    private UsuarioDTO buscarUsuarioPorId(Long id) {
        // Implementar busca por ID
        return new UsuarioDTO();
    }

    private UsuarioDTO atualizarUsuario(Long id, UsuarioDTO dados) {
        // Implementar atualiza√ß√£o
        return dados;
    }
}

```

## 5. Trabalhando com Claims Customizadas

### 5.1 Inje√ß√£o de Claims

```java
@Path("/api/claims")
@ApplicationScoped
public class ClaimsResource {

    @Inject
    JsonWebToken jwt;

    // Inje√ß√£o direta de claims espec√≠ficas
    @Inject
    @Claim("email")
    String email;

    @Inject
    @Claim("userId")
    Long userId;

    @Inject
    @Claim("departamento")
    Optional<String> departamento;

    @Inject
    @Claim("nivel")
    ClaimValue<String> nivel;

    @GET
    @Path("/dados")
    @RolesAllowed("user")
    @Produces(MediaType.APPLICATION_JSON)
    public Response obterDadosUsuario() {
        Map<String, Object> dados = new HashMap<>();

        // Usando inje√ß√£o direta
        dados.put("email", email);
        dados.put("userId", userId);
        dados.put("departamento", departamento.orElse("N√£o informado"));
        dados.put("nivel", nivel.getValue());

        // Usando JWT diretamente
        dados.put("username", jwt.getName());
        dados.put("roles", jwt.getGroups());
        dados.put("issuer", jwt.getIssuer());
        dados.put("expiracao", jwt.getExpirationTime());

        // Claims customizadas
        dados.put("nome", jwt.getClaim("nome"));
        dados.put("todasClaims", jwt.getClaimNames());

        return Response.ok(dados).build();
    }

    @GET
    @Path("/validacao")
    @RolesAllowed("user")
    @Produces(MediaType.APPLICATION_JSON)
    public Response validarClaims() {
        Map<String, Object> validacao = new HashMap<>();

        // Verificar se claims existem
        validacao.put("temEmail", jwt.containsClaim("email"));
        validacao.put("temDepartamento", jwt.containsClaim("departamento"));

        // Verificar valores espec√≠ficos
        String nivelUsuario = jwt.getClaim("nivel");
        validacao.put("nivelAlto", "senior".equals(nivelUsuario) || "expert".equals(nivelUsuario));

        // Verificar expira√ß√£o
        long exp = jwt.getExpirationTime();
        long agora = Instant.now().getEpochSecond();
        validacao.put("tempoRestante", exp - agora);
        validacao.put("proximoExpiracao", exp - agora < 300); // 5 minutos

        return Response.ok(validacao).build();
    }
}

```

### 5.2 Interceptador para Claims Customizadas

```java
@InterceptorBinding
@Target({TYPE, METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface RequireClaim {
    String claim();
    String value();
}

@RequireClaim(claim = "", value = "")
@Interceptor
@Priority(Interceptor.Priority.PLATFORM_BEFORE + 200)
public class ClaimInterceptor {

    @Inject
    JsonWebToken jwt;

    @AroundInvoke
    public Object intercept(InvocationContext context) throws Exception {
        RequireClaim annotation = context.getMethod().getAnnotation(RequireClaim.class);
        if (annotation != null) {
            String claimName = annotation.claim();
            String expectedValue = annotation.value();

            if (!jwt.containsClaim(claimName)) {
                throw new ForbiddenException("Claim '" + claimName + "' n√£o encontrada");
            }

            String actualValue = jwt.getClaim(claimName);
            if (!expectedValue.equals(actualValue)) {
                throw new ForbiddenException("Valor da claim '" + claimName + "' inv√°lido");
            }
        }

        return context.proceed();
    }
}

```

## 6. Configura√ß√µes Avan√ßadas

### 6.1 M√∫ltiplos Issuers

```
# Configura√ß√£o para m√∫ltiplos issuers
mp.jwt.verify.publickey.location=META-INF/resources/publickey.pem
mp.jwt.verify.issuer=https://meuapp.com,https://parceiro.com

# Configura√ß√£o espec√≠fica por issuer
smallrye.jwt.verify.aud=meuapp,parceiro
smallrye.jwt.verify.algorithm=RS256
smallrye.jwt.path.groups=roles
smallrye.jwt.path.sub=username

```

### 6.2 Configura√ß√£o Din√¢mica

```java
@ApplicationScoped
public class JWTConfigurationProducer {

    @Produces
    @ApplicationScoped
    public JWTAuthContextInfo createJWTAuthContextInfo() {
        JWTAuthContextInfo authInfo = new JWTAuthContextInfo();

        // Configurar issuer dinamicamente
        authInfo.setIssuedBy("https://meuapp.com");

        // Configurar algoritmo
        authInfo.setSignatureAlgorithm(SignatureAlgorithm.RS256);

        // Configurar chave p√∫blica
        try {
            String publicKey = lerChavePublica();
            authInfo.setPublicKeyContent(publicKey);
        } catch (Exception e) {
            throw new RuntimeException("Erro ao carregar chave p√∫blica", e);
        }

        // Configurar claims customizadas
        authInfo.setDefaultGroupsClaim("roles");
        authInfo.setDefaultSubClaim("username");

        return authInfo;
    }

    private String lerChavePublica() throws Exception {
        // Implementar leitura da chave p√∫blica
        return Files.readString(Paths.get("src/main/resources/META-INF/resources/publickey.pem"));
    }
}

```

### 6.3 Valida√ß√£o Customizada

```java
@ApplicationScoped
public class CustomJWTValidator {

    @Inject
    JsonWebToken jwt;

    public void validarToken() {
        // Validar claims obrigat√≥rias
        if (!jwt.containsClaim("email")) {
            throw new UnauthorizedException("Token deve conter claim 'email'");
        }

        // Validar formato do email
        String email = jwt.getClaim("email");
        if (!email.matches("^[A-Za-z0-9+_.-]+@(.+)$")) {
            throw new UnauthorizedException("Formato de email inv√°lido");
        }

        // Validar departamento
        Optional<String> dept = jwt.claim("departamento");
        if (dept.isPresent() && !List.of("TI", "RH", "VENDAS").contains(dept.get())) {
            throw new UnauthorizedException("Departamento inv√°lido");
        }

        // Validar expira√ß√£o customizada
        long exp = jwt.getExpirationTime();
        long now = Instant.now().getEpochSecond();
        if (exp - now < 300) { // 5 minutos
            throw new UnauthorizedException("Token pr√≥ximo do vencimento");
        }
    }
}

```

## 7. Integra√ß√£o com Frontend

### 7.1 Exemplo de Cliente JavaScript

```jsx
class AuthClient {
    constructor(baseUrl) {
        this.baseUrl = baseUrl;
        this.token = localStorage.getItem('access_token');
        this.refreshToken = localStorage.getItem('refresh_token');
    }

    async login(username, password) {
        try {
            const response = await fetch(`${this.baseUrl}/auth/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ username, password })
            });

            if (!response.ok) {
                throw new Error('Credenciais inv√°lidas');
            }

            const data = await response.json();
            this.token = data.accessToken;
            this.refreshToken = data.refreshToken;

            // Armazenar tokens
            localStorage.setItem('access_token', this.token);
            localStorage.setItem('refresh_token', this.refreshToken);

            return data;
        } catch (error) {
            console.error('Erro no login:', error);
            throw error;
        }
    }

    async makeAuthenticatedRequest(url, options = {}) {
        const headers = {
            ...options.headers,
            'Authorization': `Bearer ${this.token}`
        };

        try {
            const response = await fetch(url, {
                ...options,
                headers
            });

            if (response.status === 401) {
                // Token expirado, tentar refresh
                await this.refreshAccessToken();

                // Tentar novamente com novo token
                headers['Authorization'] = `Bearer ${this.token}`;
                return fetch(url, { ...options, headers });
            }

            return response;
        } catch (error) {
            console.error('Erro na requisi√ß√£o:', error);
            throw error;
        }
    }

    async refreshAccessToken() {
        try {
            const response = await fetch(`${this.baseUrl}/auth/refresh`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ refreshToken: this.refreshToken })
            });

            if (!response.ok) {
                this.logout();
                throw new Error('Refresh token inv√°lido');
            }

            const data = await response.json();
            this.token = data.accessToken;
            localStorage.setItem('access_token', this.token);

        } catch (error) {
            console.error('Erro no refresh:', error);
            this.logout();
            throw error;
        }
    }

    logout() {
        this.token = null;
        this.refreshToken = null;
        localStorage.removeItem('access_token');
        localStorage.removeItem('refresh_token');
    }

    isAuthenticated() {
        return !!this.token;
    }

    getToken() {
        return this.token;
    }
}

// Uso pr√°tico
const authClient = new AuthClient('http://localhost:8080');

// Login
authClient.login('admin', 'senha123')
    .then(data => console.log('Login realizado:', data))
    .catch(error => console.error('Erro:', error));

// Fazer requisi√ß√£o autenticada
authClient.makeAuthenticatedRequest('http://localhost:8080/api/protected/info')
    .then(response => response.json())
    .then(data => console.log('Dados do usu√°rio:', data));

```

### 7.2 Interceptador HTTP para Refresh Autom√°tico

```java
@ApplicationScoped
public class JWTRefreshFilter implements ContainerRequestFilter {

    @Inject
    TokenService tokenService;

    @Override
    public void filter(ContainerRequestContext requestContext) throws IOException {
        String authHeader = requestContext.getHeaderString("Authorization");

        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7);

            try {
                // Verificar se o token est√° pr√≥ximo do vencimento
                if (tokenProximoVencimento(token)) {
                    // Renovar token automaticamente
                    String novoToken = renovarToken(token);

                    // Adicionar novo token no header de resposta
                    requestContext.getHeaders().add("X-New-Token", novoToken);
                }
            } catch (Exception e) {
                // Log do erro, mas n√£o bloquear a requisi√ß√£o
                System.err.println("Erro ao renovar token: " + e.getMessage());
            }
        }
    }

    private boolean tokenProximoVencimento(String token) {
        // Implementar verifica√ß√£o de expira√ß√£o
        return false; // Placeholder
    }

    private String renovarToken(String token) {
        // Implementar renova√ß√£o de token
        return token; // Placeholder
    }
}

```

## 8. Testes Completos

### 8.1 Testes de Integra√ß√£o

```java
@QuarkusTest
public class AuthResourceTest {

    @Test
    public void testLoginSucesso() {
        LoginRequest request = new LoginRequest();
        request.username = "admin";
        request.password = "senha123";

        given()
            .contentType(ContentType.JSON)
            .body(request)
            .when()
            .post("/auth/login")
            .then()
            .statusCode(200)
            .body("accessToken", notNullValue())
            .body("refreshToken", notNullValue())
            .body("tokenType", equalTo("Bearer"))
            .body("usuario.username", equalTo("admin"));
    }

    @Test
    public void testLoginCredenciaisInvalidas() {
        LoginRequest request = new LoginRequest();
        request.username = "admin";
        request.password = "senhaerrada";

        given()
            .contentType(ContentType.JSON)
            .body(request)
            .when()
            .post("/auth/login")
            .then()
            .statusCode(401)
            .body("message", equalTo("Credenciais inv√°lidas"));
    }

    @Test
    public void testEndpointProtegidoComToken() {
        // Gerar token para teste
        String token = Jwt.issuer("https://meuapp.com")
                .upn("testuser")
                .groups(Set.of("user"))
                .claim("email", "test@example.com")
                .expiresAt(Instant.now().plus(1, ChronoUnit.HOURS))
                .sign();

        given()
            .header("Authorization", "Bearer " + token)
            .when()
            .get("/api/protected/info")
            .then()
            .statusCode(200)
            .body("username", equalTo("testuser"))
            .body("email", equalTo("test@example.com"));
    }

    @Test
    public void testEndpointProtegidoSemToken() {
        given()
            .when()
            .get("/api/protected/info")
            .then()
            .statusCode(401);
    }

    @Test
    public void testEndpointAdminComRoleUser() {
        String token = Jwt.issuer("https://meuapp.com")
                .upn("user")
                .groups(Set.of("user"))
                .expiresAt(Instant.now().plus(1, ChronoUnit.HOURS))
                .sign();

        given()
            .header("Authorization", "Bearer " + token)
            .when()
            .get("/api/protected/admin")
            .then()
            .statusCode(403);
    }
}

```
